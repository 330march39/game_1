<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>ナンプレ</title>
  <!-- React, ReactDOM, and Babel -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          screens: {
            'landscape': {'raw': '(orientation: landscape)'},
            'portrait': {'raw': '(orientation: portrait)'},
            'short': {'raw': '(max-height: 600px)'}
          },
          animation: {
            'bounce-slow': 'bounce 3s infinite',
          }
        }
      }
    }
  </script>
  <style>
    /* セーフエリア対応 */
    @supports (padding-top: env(safe-area-inset-top)) {
      .pt-safe { padding-top: env(safe-area-inset-top); }
      .pb-safe { padding-bottom: env(safe-area-inset-bottom); }
      .pl-safe { padding-left: env(safe-area-inset-left); }
      .pr-safe { padding-right: env(safe-area-inset-right); }
    }

    /* カスタムアニメーション定義 */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-4px); }
      75% { transform: translateX(4px); }
    }
    .animate-shake {
      animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
    }
    @keyframes pop {
      0% { transform: scale(0.8); opacity: 0.5; }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); opacity: 1; }
    }
    .animate-pop {
      animation: pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    /* 紙吹雪の修正: 上空から降ってくるように調整 */
    @keyframes confetti {
      0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
      100% { transform: translateY(110vh) rotate(720deg); opacity: 0; }
    }
    .animate-confetti {
      animation: confetti 3s ease-out forwards;
    }

    /* ウェーブアニメーション（揃ったときに光る） */
    /* サイズ変更を削除し、色が光るだけにしました */
    @keyframes wave {
      0% { background-color: transparent; }
      30% { background-color: rgba(250, 204, 21, 0.8); } /* yellow-400 */
      100% { background-color: #fefce8; } /* ガイドの色（yellow-50）で終わる */
    }
    .animate-wave {
      /* forwardsを指定しつつ、最後を透明にすることで本来の背景色を透過させます */
      animation: wave 0.6s ease-out forwards;
    }
    .animate-fade-in {
      animation: fadeIn 0.3s ease-out forwards;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    /* 全体の選択防止と固定 */
    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden; /* スクロール禁止 */
      overscroll-behavior: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      position: fixed; /* iOSでのバウンス防止 */
      top: 0;
      left: 0;
    }
    #root {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    /* スクロールバーのカスタマイズ */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 3px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #94a3b8;
    }

    /* ボードのアスペクト比維持 */
    .board-container {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      padding: 4px;
    }
    
    .sudoku-board-wrapper {
      width: 100%;
      height: 100%;
      max-width: min(100vw, 100vh);  /* 画面の短辺に合わせる */
      max-height: min(100vw, 100vh);
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .sudoku-board {
      aspect-ratio: 1 / 1; /* 正方形を強制 */
      width: 100%;         /* wrapper の中で最大まで広げる */
      height: auto;        /* aspect-ratio に任せる */
    }

  </style>
</head>
<body class="bg-slate-50 text-slate-800">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    /**
     * --- ICONS ---
     */
    const IconBase = ({ size = 24, className = "", children, ...props }) => (
      <svg 
        xmlns="http://www.w3.org/2000/svg" 
        width={size} 
        height={size} 
        viewBox="0 0 24 24" 
        fill="none" 
        stroke="currentColor" 
        strokeWidth="2.5" 
        strokeLinecap="round" 
        strokeLinejoin="round" 
        className={className}
        {...props}
      >
        {children}
      </svg>
    );

    const RefreshCw = (props) => (
      <IconBase {...props}>
        <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
        <path d="M21 3v5h-5"/>
        <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
        <path d="M8 16H3v5"/>
      </IconBase>
    );

    const Trophy = (props) => (
      <IconBase {...props}>
        <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/>
        <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/>
        <path d="M4 22h16"/>
        <path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/>
        <path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/>
        <path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/>
      </IconBase>
    );

    const Eraser = (props) => (
      <IconBase {...props}>
        <path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/>
        <path d="M22 21H7"/>
        <path d="m5 11 9 9"/>
      </IconBase>
    );

    const Clock = (props) => (
      <IconBase {...props}>
        <circle cx="12" cy="12" r="10"/>
        <polyline points="12 6 12 12 16 14"/>
      </IconBase>
    );

    const Heart = (props) => (
      <IconBase {...props}>
        <path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z"/>
      </IconBase>
    );

    const ArrowLeft = (props) => (
      <IconBase {...props}>
        <line x1="19" y1="12" x2="5" y2="12"></line>
        <polyline points="12 19 5 12 12 5"></polyline>
      </IconBase>
    );

    const HelpCircle = (props) => (
      <IconBase {...props}>
        <circle cx="12" cy="12" r="10" />
        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3" />
        <path d="M12 17h.01" />
      </IconBase>
    );
    
    const X = (props) => (
      <IconBase {...props}>
        <path d="M18 6 6 18"/>
        <path d="m6 6 12 12"/>
      </IconBase>
    );

    const Frown = (props) => (
      <IconBase {...props}>
        <circle cx="12" cy="12" r="10"/>
        <path d="M16 16s-1.5-2-4-2-4 2-4 2"/>
        <line x1="9" y1="9" x2="9.01" y2="9"/>
        <line x1="15" y1="9" x2="15.01" y2="9"/>
      </IconBase>
    );

    const AlertCircle = (props) => (
      <IconBase {...props}>
        <circle cx="12" cy="12" r="10"/>
        <line x1="12" y1="8" x2="12" y2="12"/>
        <line x1="12" y1="16" x2="12.01" y2="16"/>
      </IconBase>
    );

    const LogOut = (props) => (
      <IconBase {...props}>
        <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/>
        <polyline points="16 17 21 12 16 7"/>
        <line x1="21" y1="12" x2="9" y2="12"/>
      </IconBase>
    );

    const Grid = (props) => (
      <IconBase {...props}>
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
        <line x1="3" y1="9" x2="21" y2="9"/>
        <line x1="3" y1="15" x2="21" y2="15"/>
        <line x1="9" y1="3" x2="9" y2="21"/>
        <line x1="15" y1="3" x2="15" y2="21"/>
      </IconBase>
    );

    /**
     * --- SUDOKU LOGIC ---
     */

    const BLANK = 0;
    const isValid = (board, row, col, num) => {
      for (let x = 0; x < 9; x++) if (board[row][x] === num) return false;
      for (let x = 0; x < 9; x++) if (board[x][col] === num) return false;
      const startRow = row - (row % 3);
      const startCol = col - (col % 3);
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          if (board[i + startRow][j + startCol] === num) return false;
        }
      }
      return true;
    };

    const solveSudoku = (board) => {
      for (let row = 0; row < 9; row++) {
        for (let col = 0; col < 9; col++) {
          if (board[row][col] === BLANK) {
            const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5);
            for (let num of nums) {
              if (isValid(board, row, col, num)) {
                board[row][col] = num;
                if (solveSudoku(board)) return true;
                board[row][col] = BLANK;
              }
            }
            return false;
          }
        }
      }
      return true;
    };

    const generatePuzzle = (difficulty) => {
      const board = Array.from({ length: 9 }, () => Array(9).fill(BLANK));
      solveSudoku(board);
      const solution = board.map(row => [...row]);
      let attempts = difficulty === 'easy' ? 30 : difficulty === 'medium' ? 45 : 54;
      while (attempts > 0) {
        let row = Math.floor(Math.random() * 9);
        let col = Math.floor(Math.random() * 9);
        if (board[row][col] !== 0) {
          board[row][col] = BLANK;
          attempts--;
        }
      }
      return { initial: board, solution };
    };

    const formatTime = (seconds) => {
      const m = Math.floor(seconds / 60).toString().padStart(2, '0');
      const s = (seconds % 60).toString().padStart(2, '0');
      return `${m}:${s}`;
    };

    /**
     * --- COMPONENTS ---
     */

    const StartScreen = ({ onStart, bestTimes }) => {
      const [showRules, setShowRules] = useState(false);

      return (
        <div className="flex w-full h-full overflow-hidden bg-gradient-to-br from-indigo-50 to-white relative">
          
          {/* 背景装飾 */}
          <div className="absolute top-[-10%] right-[-5%] w-[40vw] h-[40vw] bg-indigo-100 rounded-full blur-3xl opacity-50 pointer-events-none"></div>
          <div className="absolute bottom-[-10%] left-[-5%] w-[40vw] h-[40vw] bg-purple-100 rounded-full blur-3xl opacity-50 pointer-events-none"></div>

          <div className="w-full h-full flex flex-col md:flex-row items-center justify-center p-6 md:p-12 gap-6 md:gap-16 relative z-10 overflow-y-auto">
            
            {/* 左側（モバイルでは上部）：タイトル＆ベストタイムエリア */}
            <div className="flex flex-col items-center md:items-end md:text-right w-full max-w-md shrink-0">
              <div className="mb-2 text-center md:text-right">
                <h1 className="text-6xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-r from-indigo-600 to-purple-600 tracking-tighter drop-shadow-sm select-none">
                  ナンプレ
                </h1>
                <p className="text-slate-400 font-bold tracking-[0.3em] text-sm md:text-lg select-none">NUMBER PUZZLE</p>
              </div>

              {/* ベストタイム表示（レスポンシブ：横画面では縦並び、縦画面では横並び） */}
              <div className="w-full mt-4 md:mt-8">
                <div className="bg-white/80 backdrop-blur-md p-3 md:p-4 rounded-2xl shadow-lg border border-white/60">
                  <h2 className="text-xs font-bold text-slate-500 mb-2 flex items-center justify-center md:justify-start gap-2 uppercase tracking-wider">
                    <Trophy size={14} className="text-yellow-500" /> Best Times
                  </h2>
                  <div className="grid grid-cols-3 md:grid-cols-1 gap-2">
                    <div className="flex flex-col md:flex-row items-center justify-center md:justify-between p-2 md:px-3 md:py-2 bg-green-50/50 rounded-xl border border-green-100">
                      <span className="text-green-700 font-bold text-xs mb-1 md:mb-0">やさしい</span>
                      <span className="font-bold text-slate-700 text-sm md:text-base tabular-nums">{bestTimes.easy ? formatTime(bestTimes.easy) : '--:--'}</span>
                    </div>
                    <div className="flex flex-col md:flex-row items-center justify-center md:justify-between p-2 md:px-3 md:py-2 bg-yellow-50/50 rounded-xl border border-yellow-100">
                      <span className="text-yellow-700 font-bold text-xs mb-1 md:mb-0">ふつう</span>
                      <span className="font-bold text-slate-700 text-sm md:text-base tabular-nums">{bestTimes.medium ? formatTime(bestTimes.medium) : '--:--'}</span>
                    </div>
                    <div className="flex flex-col md:flex-row items-center justify-center md:justify-between p-2 md:px-3 md:py-2 bg-red-50/50 rounded-xl border border-red-100">
                      <span className="text-red-700 font-bold text-xs mb-1 md:mb-0">むずかしい</span>
                      <span className="font-bold text-slate-700 text-sm md:text-base tabular-nums">{bestTimes.hard ? formatTime(bestTimes.hard) : '--:--'}</span>
                    </div>
                  </div>
                </div>
              </div>
              
              <button 
                onClick={() => setShowRules(true)}
                className="mt-6 flex items-center gap-2 text-indigo-500 hover:text-indigo-700 font-bold bg-white px-4 py-2 rounded-full shadow-sm hover:shadow-md transition-all text-sm md:text-base"
              >
                <HelpCircle size={20} /> ルールを見る
              </button>
            </div>

            {/* 右側（モバイルでは下部）：アクションエリア */}
            <div className="w-full max-w-sm flex flex-col gap-6 shrink-0">
              {/* スタートボタン */}
              <div className="grid grid-cols-1 gap-3">
                <button onClick={() => onStart('easy')} className="group relative overflow-hidden bg-gradient-to-r from-emerald-400 to-emerald-500 text-white py-4 rounded-2xl font-bold shadow-lg shadow-emerald-200 transition-all hover:scale-[1.02] active:scale-95 text-lg flex items-center justify-center">
                  <span className="absolute inset-0 bg-white/20 translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-500"></span>
                  やさしい
                </button>
                <button onClick={() => onStart('medium')} className="group relative overflow-hidden bg-gradient-to-r from-amber-400 to-amber-500 text-white py-4 rounded-2xl font-bold shadow-lg shadow-amber-200 transition-all hover:scale-[1.02] active:scale-95 text-lg flex items-center justify-center">
                  <span className="absolute inset-0 bg-white/20 translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-500"></span>
                  ふつう
                </button>
                <button onClick={() => onStart('hard')} className="group relative overflow-hidden bg-gradient-to-r from-rose-400 to-rose-500 text-white py-4 rounded-2xl font-bold shadow-lg shadow-rose-200 transition-all hover:scale-[1.02] active:scale-95 text-lg flex items-center justify-center">
                  <span className="absolute inset-0 bg-white/20 translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-500"></span>
                  むずかしい
                </button>
              </div>
            </div>

            {/* Rules Modal */}
            {showRules && (
              <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
                <div className="absolute inset-0 bg-slate-900/40 backdrop-blur-sm" onClick={() => setShowRules(false)}></div>
                <div className="bg-white rounded-3xl p-6 w-full max-w-xl max-h-[90vh] overflow-y-auto shadow-2xl relative z-10 animate-pop flex flex-col">
                  <button 
                    onClick={() => setShowRules(false)}
                    className="absolute top-4 right-4 p-2 text-slate-400 hover:text-slate-600 hover:bg-slate-100 rounded-full transition-colors"
                  >
                    <X size={24} />
                  </button>
                  <h2 className="text-2xl font-bold text-indigo-600 mb-6 flex items-center gap-2 shrink-0">
                    <HelpCircle size={28} /> ルール
                  </h2>
                  <div className="space-y-6 overflow-y-auto p-1">
                    <div className="space-y-4 text-slate-600 font-medium">
                        <div className="flex gap-4 items-start">
                          <span className="bg-indigo-100 text-indigo-600 w-8 h-8 rounded-xl flex items-center justify-center text-sm font-bold shrink-0">1</span>
                          <p className="pt-1">空いているマスに <span className="text-indigo-600 font-bold bg-indigo-50 px-1 rounded">1〜9</span> の数字を入れます。</p>
                        </div>
                        <div className="flex gap-4 items-start">
                          <span className="bg-indigo-100 text-indigo-600 w-8 h-8 rounded-xl flex items-center justify-center text-sm font-bold shrink-0">2</span>
                          <p className="pt-1">
                            縦・横の列、太枠の3×3ブロック内で<br/>
                            数字が <span className="text-indigo-600 font-bold border-b-2 border-indigo-200">重複してはいけません</span>。
                          </p>
                        </div>
                        <div className="flex gap-4 items-start">
                          <span className="bg-indigo-100 text-indigo-600 w-8 h-8 rounded-xl flex items-center justify-center text-sm font-bold shrink-0">3</span>
                          <p className="pt-1"><span className="text-rose-500 font-bold bg-rose-50 px-1 rounded">3回ミス</span>するとゲームオーバーです。</p>
                        </div>
                    </div>
                    
                    <div className="bg-slate-50 rounded-2xl p-6 text-center border border-slate-100">
                        <div className="inline-grid grid-cols-3 gap-1 mb-3 p-2 bg-white rounded-lg shadow-sm border border-slate-200">
                            <div className="w-8 h-8 bg-indigo-100 rounded flex items-center justify-center font-bold text-indigo-600">1</div>
                            <div className="w-8 h-8 bg-white rounded border border-slate-100"></div>
                            <div className="w-8 h-8 bg-white rounded border border-slate-100"></div>
                            <div className="w-8 h-8 bg-white rounded border border-slate-100"></div>
                            <div className="w-8 h-8 bg-indigo-100 rounded flex items-center justify-center font-bold text-indigo-600">2</div>
                            <div className="w-8 h-8 bg-white rounded border border-slate-100"></div>
                            <div className="w-8 h-8 bg-white rounded border border-slate-100"></div>
                            <div className="w-8 h-8 bg-white rounded border border-slate-100"></div>
                            <div className="w-8 h-8 bg-indigo-100 rounded flex items-center justify-center font-bold text-indigo-600">3</div>
                        </div>
                        <p className="text-sm text-slate-500 font-bold">タテ・ヨコ・3x3エリアで<br/>数字がかぶらないようにしよう！</p>
                    </div>
                  </div>
                  <button 
                    onClick={() => setShowRules(false)}
                    className="mt-6 bg-indigo-600 text-white py-3 px-6 rounded-xl font-bold w-full hover:bg-indigo-700 transition-colors shadow-lg shadow-indigo-200"
                  >
                    わかった！
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    };

    const App = () => {
      const [isGameStarted, setIsGameStarted] = useState(false);
      const [gameData, setGameData] = useState({ initial: [], solution: [] });
      const [board, setBoard] = useState([]);
      const [selected, setSelected] = useState(null);
      const [difficulty, setDifficulty] = useState('easy');
      const [mistakes, setMistakes] = useState(0);
      const [isWon, setIsWon] = useState(false);
      const [timer, setTimer] = useState(0);
      const [bestTimes, setBestTimes] = useState({ easy: null, medium: null, hard: null });
      const [showQuitConfirm, setShowQuitConfirm] = useState(false);
      
      const [shakeCell, setShakeCell] = useState(null);
      const [popCell, setPopCell] = useState(null);
      const [waveCells, setWaveCells] = useState([]);

      useEffect(() => {
        const saved = localStorage.getItem('sudoku_best_times');
        if (saved) setBestTimes(JSON.parse(saved));
      }, []);

      const saveBestTime = (time, diff) => {
        const currentBest = bestTimes[diff];
        if (currentBest === null || time < currentBest) {
          const newBestTimes = { ...bestTimes, [diff]: time };
          setBestTimes(newBestTimes);
          localStorage.setItem('sudoku_best_times', JSON.stringify(newBestTimes));
        }
      };

      const startNewGame = useCallback((diff = difficulty) => {
        const { initial, solution } = generatePuzzle(diff);
        setGameData({ initial, solution });
        setBoard(initial.map(row => [...row]));
        setMistakes(0);
        setIsWon(false);
        setTimer(0);
        setSelected(null);
        setDifficulty(diff);
        setShowQuitConfirm(false);
      }, [difficulty]);

      const startGame = (diff) => {
        startNewGame(diff);
        setIsGameStarted(true);
      };

      useEffect(() => {
        let interval;
        if (isGameStarted && !isWon && !showQuitConfirm && mistakes < 3) {
          interval = setInterval(() => setTimer(prev => prev + 1), 1000);
        }
        return () => clearInterval(interval);
      }, [isGameStarted, isWon, showQuitConfirm, mistakes]);

      // ウェーブエフェクト（中心から広がるように計算）
      const checkAndAnimateLines = (currentBoard, r, c) => {
        const newWaveCells = [];
        const sol = gameData.solution;

        // 行完成チェック
        const isRowComplete = currentBoard[r].every((val, idx) => val === sol[r][idx]);
        // 列完成チェック
        const isColComplete = currentBoard.every((row, idx) => row[c] === sol[idx][c]);
        // ボックス完成チェック
        const startR = r - (r % 3), startC = c - (c % 3);
        let isBoxComplete = true;
        for (let i = 0; i < 3; i++) {
          for (let j = 0; j < 3; j++) {
            if (currentBoard[startR + i][startC + j] !== sol[startR + i][startC + j]) isBoxComplete = false;
          }
        }

        const addWave = (cells) => {
          cells.forEach(cell => {
            // 入力マス(r, c)からの距離を計算してディレイをかける
            const dist = Math.abs(cell.r - r) + Math.abs(cell.c - c);
            newWaveCells.push({ ...cell, delay: dist * 60 });
          });
        };

        if (isRowComplete) addWave(currentBoard[r].map((_, idx) => ({ r: r, c: idx })));
        if (isColComplete) addWave(currentBoard.map((_, idx) => ({ r: idx, c: c })));
        if (isBoxComplete) {
          const boxCells = [];
          for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) boxCells.push({ r: startR + i, c: startC + j });
          }
          addWave(boxCells);
        }

        if (newWaveCells.length > 0) {
          setWaveCells(prev => [...prev, ...newWaveCells]);
          setTimeout(() => setWaveCells([]), 1000);
        }
      };

      const checkIsComplete = (currentBoard) => {
        for (let i = 0; i < 9; i++) {
          for (let j = 0; j < 9; j++) {
            if (currentBoard[i][j] !== gameData.solution[i][j]) return false;
          }
        }
        return true;
      };

      const handleNumberInput = (num) => {
        if (!selected || isWon || mistakes >= 3 || showQuitConfirm) return;
        const { r, c } = selected;
        if (gameData.initial[r][c] !== BLANK) return;

        if (num === 0) {
          const newBoard = board.map((row, ri) => ri === r ? row.map((val, ci) => ci === c ? 0 : val) : row);
          setBoard(newBoard);
          return;
        }

        if (gameData.solution[r][c] === num) {
          const newBoard = board.map((row, ri) => ri === r ? row.map((val, ci) => ci === c ? num : val) : row);
          setBoard(newBoard);
          setPopCell(`${r}-${c}`);
          setTimeout(() => setPopCell(null), 300);
          checkAndAnimateLines(newBoard, r, c);

          if (checkIsComplete(newBoard)) {
            // ウェーブが終わるのを待ってから勝利判定
            setTimeout(() => {
              setIsWon(true);
              saveBestTime(timer, difficulty);
            }, 1200); 
          }
        } else {
          setMistakes(prev => prev + 1);
          setShakeCell(`${r}-${c}`);
          setTimeout(() => setShakeCell(null), 400);
        }
      };

      // キーボード入力
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (!isGameStarted || isWon || mistakes >= 3) return;
          if (e.key >= '1' && e.key <= '9') handleNumberInput(parseInt(e.key));
          else if (e.key === 'Backspace') handleNumberInput(0);
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [isGameStarted, selected, isWon, board, mistakes]);


      // タイトルへ戻る処理（確実にリセットする）
      const handleBackToTitle = () => {
        setIsWon(false);
        setIsGameStarted(false);
        setMistakes(0);
        setTimer(0);
      };

      // Handle Keydown
      useEffect(() => {
        const handleKeyDown = (e) => {
          if (!isGameStarted || isWon || mistakes >= 3 || showQuitConfirm) return;
          
          if (e.key >= '1' && e.key <= '9') {
            handleNumberInput(parseInt(e.key));
          } else if (e.key === 'Backspace' || e.key === 'Delete') {
            handleNumberInput(0);
          } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
            e.preventDefault();
            if (!selected) {
              setSelected({ r: 0, c: 0 });
              return;
            }
            let { r, c } = selected;
            if (e.key === 'ArrowUp') r = Math.max(0, r - 1);
            if (e.key === 'ArrowDown') r = Math.min(8, r + 1);
            if (e.key === 'ArrowLeft') c = Math.max(0, c - 1);
            if (e.key === 'ArrowRight') c = Math.min(8, c + 1);
            setSelected({ r, c });
          }
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [isGameStarted, selected, isWon, board, gameData, mistakes, showQuitConfirm]);

      const isNumberComplete = (num) => {
        let count = 0;
        for (let r = 0; r < 9; r++) {
          for (let c = 0; c < 9; c++) {
            if (board[r][c] === num && gameData.solution[r][c] === num) {
              count++;
            }
          }
        }
        return count === 9;
      };

      const getCellClass = (r, c, val) => {
        const isSelected = selected?.r === r && selected?.c === c;
        const isInitial = gameData.initial[r] && gameData.initial[r][c] !== BLANK;
        const isSameNumber = selected && val !== 0 && board[selected.r][selected.c] === val;
        const isRelated = selected && (selected.r === r || selected.c === c || 
          (Math.floor(selected.r/3) === Math.floor(r/3) && Math.floor(selected.c/3) === Math.floor(c/3)));
        const waveData = waveCells.find(w => w.r === r && w.c === c);
        
        let base = "w-full h-full flex items-center justify-center font-bold cursor-pointer transition-all duration-75 select-none relative ";
        
        // フォントサイズをレスポンシブに調整
        const textSize = {
            fontSize: 'max(14px, min(4.5vmin, 2rem))',
          animationDelay: waveData ? `${waveData.delay}ms` : '0s',
        };

        let border = "border border-slate-300 ";
        // 枠線の色はインディゴのままでも綺麗ですが、黄色に合わせるなら slate-400 などでも可。
        // ここでは太枠の強調色だけ少し調整しても良いですが、元のままでも違和感はありません。
        if (c % 3 === 2 && c !== 8) border += "border-r-2 border-r-indigo-400 ";
        if (r % 3 === 2 && r !== 8) border += "border-b-2 border-b-indigo-400 ";
        
        // ▼▼▼ 配色変更箇所 ▼▼▼
        let color = "bg-white text-slate-700 ";
        
        if (isInitial) color = "bg-slate-100 text-slate-900 ";
        else color = "text-indigo-600 "; // 入力数字の色（青系のままが見やすいですが、変えるなら text-yellow-600 等）

        // ガイド（縦横・ボックス）の色：薄いインディゴ → 薄い黄色 (bg-yellow-50)
        if (isRelated && !isSelected) color = "bg-yellow-50 text-slate-800 ";
        
        // 同じ数字のハイライト：少し濃い黄色 (bg-yellow-100)
        if (isSameNumber && !isSelected) color = "bg-yellow-100 text-amber-700 ";

        // 選択中のセル：ピンク → 黄色 (bg-yellow-400)
        // 初期値かどうかで少し色味を変えてもいいですが、統一して黄色にします
        if (isSelected) {
          // テキスト色は黄色背景なので黒っぽく(slate-900)します。白文字(text-white)だと黄色背景で見にくいです。
          color = "bg-yellow-400 text-slate-900 shadow-lg scale-105 z-20 rounded-md ";
          if (isInitial) color = "bg-yellow-400 text-slate-900 shadow-lg scale-105 z-20 rounded-md ";
        }

        if (shakeCell === `${r}-${c}`) base += "animate-shake bg-red-100 ";
        if (popCell === `${r}-${c}`) base += "animate-pop ";
        if (waveData) base += "animate-wave ";

        return { className: base + border + color, style: textSize };
      };

      const handleQuit = () => {
        setShowQuitConfirm(true);
      };

      const confirmQuit = () => {
        setIsGameStarted(false);
        setShowQuitConfirm(false);
      };

      const cancelQuit = () => {
        setShowQuitConfirm(false);
      };

      // --- サイドバーコンポーネント (PC/Landscape共通) ---
      const InfoPanel = ({ className }) => (
        <div className={`flex flex-col bg-white/50 backdrop-blur-sm md:bg-white md:border-r border-slate-200 items-center justify-between shrink-0 h-full py-4 px-3 overflow-y-auto ${className}`}>
          <div className="w-full flex flex-col gap-4">
            <button 
               onClick={handleQuit}
               className="flex items-center justify-center gap-2 text-slate-500 hover:text-indigo-600 font-bold transition-colors w-full p-3 hover:bg-slate-100 rounded-xl mb-2"
             >
               <ArrowLeft size={20} /> <span className="text-sm font-bold">タイトル</span>
             </button>
             
             <div className="w-full bg-white p-4 rounded-2xl shadow-sm border border-slate-100 flex flex-col items-center gap-2">
               <span className="text-[10px] font-bold text-slate-400 uppercase tracking-wider">LEVEL</span>
               <span className={`text-sm font-bold px-3 py-1 rounded-full ${difficulty === 'easy' ? 'bg-green-100 text-green-600' : difficulty === 'medium' ? 'bg-yellow-100 text-yellow-600' : 'bg-red-100 text-red-600'}`}>
                 {difficulty === 'easy' ? 'やさしい' : difficulty === 'medium' ? 'ふつう' : 'むずかしい'}
               </span>
             </div>

             <div className="w-full bg-white p-4 rounded-2xl shadow-sm border border-slate-100 flex flex-col items-center gap-2">
               <span className="text-[10px] font-bold text-slate-400 uppercase tracking-wider">TIME</span>
               <div className="flex items-center gap-2 text-indigo-900 text-xl font-bold tabular-nums">
                 <Clock size={20} className="text-indigo-400" />
                 {formatTime(timer)}
               </div>
             </div>

             <div className="w-full bg-white p-4 rounded-2xl shadow-sm border border-slate-100 flex flex-col items-center gap-2">
               <span className="text-[10px] font-bold text-slate-400 uppercase tracking-wider">LIFE</span>
               <div className="flex gap-1.5">
                 {[...Array(3)].map((_, i) => (
                   <Heart key={i} size={24} className={i < 3 - mistakes ? "text-rose-500 fill-rose-500" : "text-slate-200 fill-slate-200"} />
                 ))}
               </div>
             </div>
          </div>
          <div className="flex flex-col items-center mt-4 opacity-50">
             <Grid size={24} className="text-slate-300 mb-1" />
             <div className="text-[10px] text-slate-300 font-bold tracking-widest">NANPRE</div>
          </div>
        </div>
      );

      // --- テンキーコンポーネント (PC/Landscape共通) ---
      const NumberPad = ({ className, buttonClass }) => (
        <div className={`flex flex-col bg-white/50 backdrop-blur-sm md:bg-white md:border-l border-slate-200 p-3 items-center justify-center shrink-0 h-full overflow-y-auto ${className}`}>
           <div className="grid grid-cols-2 gap-3 w-full max-w-[180px]">
             {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => {
                const completed = isNumberComplete(num);
                if (completed) return <div key={num} className="aspect-square flex items-center justify-center text-slate-300 font-bold text-xl select-none bg-slate-50 rounded-2xl border border-slate-100">✓</div>;
                return (
                  <button
                    key={num}
                    onClick={() => handleNumberInput(num)}
                    className={`aspect-square bg-white border-b-4 border-indigo-100 active:border-b-0 active:translate-y-[2px] hover:bg-indigo-50 text-indigo-600 font-bold text-2xl rounded-2xl transition-all shadow-sm border border-indigo-200 flex items-center justify-center ${buttonClass}`}
                  >
                    {num}
                  </button>
                );
             })}
              <button
               onClick={() => handleNumberInput(0)}
               className={`aspect-square bg-slate-100 border-b-4 border-slate-200 active:border-b-0 active:translate-y-[2px] hover:bg-slate-200 text-slate-500 font-bold rounded-2xl transition-all flex items-center justify-center col-span-1 ${buttonClass}`}
             >
               <Eraser size={28} />
             </button>
           </div>
        </div>
      );

      return (
        <div className="fixed inset-0 bg-slate-100 flex items-center justify-center font-sans text-slate-800 overflow-hidden select-none">
          
          <div className="w-full h-full bg-white flex flex-col relative overflow-hidden">
            
            {!isGameStarted ? (
              <StartScreen onStart={startGame} bestTimes={bestTimes} />
            ) : (
              // -----------------------------------------------------------------------
              // メインゲームレイアウト
              // -----------------------------------------------------------------------
              <div className="flex flex-col landscape:flex-row md:flex-row h-full w-full overflow-hidden pt-safe pb-safe pl-safe pr-safe">

                {/* --- 1. 左カラム (Info) --- */}
                {/* Mobile Portrait: Header (Top) */}
                <div className="landscape:hidden md:hidden px-4 py-2 bg-white flex items-center justify-between border-b border-slate-100 shrink-0 z-20 shadow-sm">
                  <div className="flex items-center gap-3">
                    <button 
                       onClick={handleQuit}
                       className="p-2 -ml-2 rounded-full text-slate-500 hover:bg-slate-100 transition-colors flex items-center gap-1 font-bold text-sm"
                     >
                       <ArrowLeft size={22} />
                     </button>
                     <div className="h-6 w-px bg-slate-200"></div>
                     <span className={`text-xs font-bold px-2.5 py-1 rounded-full ${difficulty === 'easy' ? 'bg-green-100 text-green-600' : difficulty === 'medium' ? 'bg-yellow-100 text-yellow-600' : 'bg-red-100 text-red-600'}`}>
                        {difficulty === 'easy' ? 'やさしい' : difficulty === 'medium' ? 'ふつう' : 'むずかしい'}
                      </span>
                  </div>
                  <div className="flex items-center gap-4">
                    <div className="flex items-center gap-1.5 text-indigo-900 font-bold tabular-nums">
                      <Clock size={18} className="text-indigo-400" />
                      {formatTime(timer)}
                    </div>
                    <div className="flex gap-0.5">
                      {[...Array(3)].map((_, i) => (
                        <Heart key={i} size={20} className={i < 3 - mistakes ? "text-rose-500 fill-rose-500" : "text-slate-200 fill-slate-200"} />
                      ))}
                    </div>
                  </div>
                </div>

                {/* PC / Landscape Mobile: Left Sidebar */}
                <InfoPanel className="hidden landscape:flex md:flex w-48 shrink-0" />


                {/* --- 2. 中央カラム (Board) --- */}
                <div className="flex-grow bg-slate-50/50 relative board-container">
                  {/* wrapperを追加して正方形の中心配置を確実に */}
                  <div className="sudoku-board-wrapper">
                    <div className="sudoku-board shadow-xl rounded-lg overflow-hidden border-2 border-indigo-500 bg-white grid grid-rows-9 aspect-square max-w-full max-h-full ">
                      {board.map((row, r) => (
                        <div key={r} className="grid grid-cols-9 h-full">
                          {row.map((val, c) => {
                            const cell = getCellClass(r, c, val);
                            return (
                              <div 
                                key={`${r}-${c}`} 
                                className={cell.className}
                                style={cell.style}
                                onClick={() => setSelected({ r, c })}
                              >
                                <div className="w-full h-full min-w-0 min-h-0 flex items-center justify-center">
                                  {val !== 0 ? val : ''}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      ))}
                    </div>
                  </div>
                </div>


                {/* --- 3. 右カラム (Input) --- */}
                {/* Mobile Portrait: Footer (Bottom) */}
                <div className="landscape:hidden md:hidden px-2 py-3 bg-white border-t border-slate-100 shrink-0 pb-safe z-20">
                  <div className="grid grid-cols-5 gap-2 max-w-[500px] mx-auto px-2 h-full">
                    {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => {
                      const completed = isNumberComplete(num);
                        if (completed) return (
                        <div key={num} className="h-12 sm:h-14 flex items-center justify-center text-slate-200 font-bold text-lg select-none bg-slate-50 rounded-xl border border-slate-100">
                          ✓
                        </div>
                      );                      return (
                        <button key={num} onClick={() => handleNumberInput(num)} className="h-12 sm:h-14 bg-white border border-indigo-200 shadow-[0_4px_0_#e0e7ff] active:shadow-none active:translate-y-[4px] hover:bg-indigo-50 text-indigo-600 font-bold text-xl rounded-xl transition-all flex items-center justify-center">{num}</button>
                      );
                    })}
                    <button onClick={() => handleNumberInput(0)} className="h-12 sm:h-14 bg-slate-100 border border-slate-200 shadow-[0_4px_0_#e2e8f0] active:shadow-none active:translate-y-[4px] hover:bg-slate-200 text-slate-500 font-bold rounded-xl transition-all flex items-center justify-center"><Eraser size={24} /></button>
                  </div>
                </div>

                {/* PC / Landscape Mobile: Right Sidebar */}
                <NumberPad className="hidden landscape:flex md:flex w-48 shrink-0" />

              </div>
            )}

            {/* 確認ダイアログ (Quit Confirm) */}
            {showQuitConfirm && (
              <div className="absolute inset-0 z-50 bg-slate-900/30 backdrop-blur-sm flex items-center justify-center p-4">
                  <div className="bg-white rounded-3xl p-8 max-w-sm w-full shadow-2xl animate-pop text-center">
                    <div className="w-16 h-16 bg-yellow-100 text-yellow-500 rounded-full flex items-center justify-center mx-auto mb-4">
                      <AlertCircle size={32} />
                    </div>
                    <h3 className="text-xl font-bold text-slate-800 mb-2">タイトルに戻りますか？</h3>
                    <p className="text-slate-500 mb-8 text-sm">現在のゲーム進行状況は失われます。</p>
                    <div className="flex gap-3">
                      <button onClick={cancelQuit} className="flex-1 py-3 rounded-xl font-bold text-slate-600 bg-slate-100 hover:bg-slate-200 transition-colors">
                        キャンセル
                      </button>
                      <button onClick={confirmQuit} className="flex-1 py-3 rounded-xl font-bold text-white bg-rose-500 hover:bg-rose-600 transition-colors">
                        戻る
                      </button>
                    </div>
                  </div>
              </div>
            )}

            {/* ゲームオーバーオーバーレイ */}
            {isGameStarted && mistakes >= 3 && !isWon && (
              <div className="absolute inset-0 z-30 bg-white/90 backdrop-blur-sm flex flex-col items-center justify-center animate-fade-in p-6 text-center">
                <div className="text-rose-500 mb-6 animate-bounce">
                  <Frown size={80} strokeWidth={1.5} />
                </div>
                <h2 className="text-3xl font-black text-slate-800 mb-2">Game Over</h2>
                <p className="text-slate-500 mb-8">また挑戦しよう！</p>
                <button 
                  onClick={() => startNewGame(difficulty)}
                  className="w-full max-w-xs bg-indigo-600 hover:bg-indigo-700 text-white py-4 rounded-2xl font-bold shadow-xl shadow-indigo-200 transition-all hover:scale-105 active:scale-95 flex items-center justify-center gap-2"
                >
                  <RefreshCw size={20} /> もう一度プレイ
                </button>
                <button 
                  onClick={() => setIsGameStarted(false)}
                  className="mt-4 text-slate-400 font-bold text-sm hover:text-slate-600 flex items-center gap-2"
                >
                  <LogOut size={16} /> タイトルに戻る
                </button>
              </div>
            )}

            {/* 勝利画面 */}
            {isWon && (
              <div className="absolute inset-0 z-50 bg-gradient-to-b from-indigo-600/95 to-purple-700/95 backdrop-blur-md flex flex-col items-center justify-center animate-fade-in text-white p-6 text-center">
                {/* 紙吹雪 */}
                <div className="absolute inset-0 overflow-hidden pointer-events-none">
                  {[...Array(50)].map((_, i) => (
                    <div key={i} className="absolute w-3 h-3 bg-yellow-300 rounded-full animate-confetti" 
                      style={{
                        left: `${Math.random() * 100}%`,
                        top: '-20px',
                        animationDelay: `${Math.random() * 3}s`,
                        backgroundColor: ['#fbbf24', '#f472b6', '#34d399', '#60a5fa', '#fff'][Math.floor(Math.random()*5)]
                      }}
                    />
                  ))}
                </div>
                
                <Trophy size={80} className="text-yellow-300 mb-6 animate-bounce drop-shadow-lg relative z-10" />
                <h2 className="text-5xl font-black mb-2 tracking-tighter relative z-10">CLEAR!</h2>
                
                <div className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-8 w-full max-w-xs border border-white/20 relative z-10">
                  <p className="text-indigo-200 font-bold text-sm mb-1">TIME</p>
                  <p className="text-4xl font-bold mb-4 tabular-nums">{formatTime(timer)}</p>
                  
                  {bestTimes[difficulty] === timer && (
                    <div className="inline-block bg-yellow-400 text-yellow-900 text-xs font-black px-3 py-1 rounded-full animate-pulse">
                      NEW RECORD!
                    </div>
                  )}
                </div>
                
                <div className="flex flex-col gap-3 w-full max-w-xs relative z-[60]"> {/* z-indexを60に上げてボタンを最前面に */}
                  <button 
                    onClick={() => startNewGame()}
                    className="bg-white text-indigo-600 py-4 rounded-2xl font-bold shadow-lg transition-all hover:scale-105 active:scale-95 flex items-center justify-center gap-2 cursor-pointer"
                  >
                    <RefreshCw size={20} /> 同じ難易度で遊ぶ
                  </button>
                  
                  {/* タイトルへ戻るボタンの修正 */}
                  <button 
                    onClick={handleBackToTitle}
                    className="bg-indigo-800/50 text-indigo-100 py-4 rounded-2xl font-bold hover:bg-indigo-800/70 transition-all flex items-center justify-center gap-2 cursor-pointer"
                  >
                    <LogOut size={18} /> タイトルへ戻る
                  </button>
                </div>
              </div>
            )}

          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
