<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON WORD BATTLE</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- PeerJS (WebRTC Wrapper) -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Google Fonts -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=M+PLUS+Rounded+1c:wght@400;700;900&display=swap');
        
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #050505;
            color: #e2e8f0;
            overflow: hidden; /* Prevent pull-to-refresh on mobile */
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: #1e293b; 
        }
        ::-webkit-scrollbar-thumb {
            background: #475569; 
            border-radius: 3px;
        }

        /* Animations */
        .animate-shake {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-2px, 0, 0); }
            20%, 80% { transform: translate3d(4px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-8px, 0, 0); }
            40%, 60% { transform: translate3d(8px, 0, 0); }
        }

        .neon-text {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #0ff, 0 0 30px #0ff, 0 0 40px #0ff;
        }
        .neon-box {
            box-shadow: 0 0 5px #0ff, 0 0 10px #0ff inset;
        }
        .neon-text-pink {
            text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #f0f, 0 0 30px #f0f, 0 0 40px #f0f;
        }
        .neon-box-pink {
            box-shadow: 0 0 5px #f0f, 0 0 10px #f0f inset;
        }

        .bg-grid {
            background-image: linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 30px 30px;
        }

        .chat-bubble {
            position: relative;
            max-width: 80%;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .chat-bubble.mine {
            background: linear-gradient(135deg, #0284c7, #2563eb);
            color: white;
            border-bottom-right-radius: 4px;
            margin-left: auto;
        }
        .chat-bubble.opponent {
            background: linear-gradient(135deg, #334155, #475569);
            color: #e2e8f0;
            border-bottom-left-radius: 4px;
            margin-right: auto;
        }
    </style>
</head>
<body class="bg-grid min-h-screen flex flex-col">
    <div id="root" class="flex-1 flex flex-col h-full"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- Utils ---
        const generateShortId = () => {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let result = '';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        };

        const toHiragana = (str) => {
            return str.replace(/[\u30a1-\u30f6]/g, match => {
                const chr = match.charCodeAt(0) - 0x60;
                return String.fromCharCode(chr);
            });
        };

        const getLastChar = (word) => {
            if (!word) return '';
            const last = word.slice(-1);
            const map = {'ぁ':'あ','ぃ':'い','ぅ':'う','ぇ':'え','ぉ':'お','っ':'つ','ゃ':'や','ゅ':'ゆ','ょ':'よ','ゎ':'わ'};
            if (map[last]) return map[last];
            if (last === 'ー') {
                const prev = word.slice(-2, -1);
                if (map[prev]) return map[prev];
                return prev;
            }
            return last;
        };

        // --- Components ---

        const Button = ({ onClick, children, className = "", disabled = false, variant = "primary", size = "md" }) => {
            const baseStyle = "font-black tracking-wider uppercase transition-all transform active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2";
            
            const sizes = {
                sm: "px-3 py-1 text-sm rounded-lg",
                md: "px-6 py-3 text-lg rounded-xl",
                lg: "px-8 py-4 text-xl rounded-2xl"
            };

            const variants = {
                primary: "bg-cyan-500 hover:bg-cyan-400 text-black shadow-[0_0_15px_rgba(6,182,212,0.6)] border-2 border-cyan-300",
                danger: "bg-pink-600 hover:bg-pink-500 text-white shadow-[0_0_15px_rgba(236,72,153,0.6)] border-2 border-pink-400",
                secondary: "bg-slate-800 hover:bg-slate-700 text-slate-300 border-2 border-slate-600",
                ghost: "bg-transparent hover:bg-white/10 text-slate-400"
            };

            return (
                <button 
                    onClick={onClick} 
                    disabled={disabled}
                    className={`${baseStyle} ${sizes[size]} ${variants[variant]} ${className}`}
                >
                    {children}
                </button>
            );
        };

        const GameInput = ({ value, onChange, placeholder, onKeyDown, autoFocus, disabled }) => (
            <div className="relative w-full group">
                <input
                    type="text"
                    value={value}
                    onChange={onChange}
                    onKeyDown={onKeyDown}
                    placeholder={placeholder}
                    autoFocus={autoFocus}
                    disabled={disabled}
                    className="w-full bg-slate-900/90 border-2 border-slate-600 focus:border-cyan-400 text-white px-4 py-4 rounded-xl outline-none transition-all text-xl font-bold tracking-wider placeholder:text-slate-600 disabled:opacity-50 disabled:bg-slate-950"
                />
                <div className="absolute inset-0 rounded-xl pointer-events-none border-2 border-transparent group-focus-within:shadow-[0_0_15px_rgba(34,211,238,0.3)] transition-all"></div>
            </div>
        );

        const LifeBar = ({ hp, maxHp = 3, isSelf }) => {
            return (
                <div className={`flex flex-col ${isSelf ? 'items-end' : 'items-start'} w-full max-w-[150px]`}>
                    <div className="flex gap-1 mb-1">
                        {[...Array(maxHp)].map((_, i) => (
                            <div 
                                key={i}
                                className={`h-3 w-8 -skew-x-12 transition-all duration-300 ${
                                    i < hp 
                                        ? (isSelf ? 'bg-cyan-400 shadow-[0_0_8px_rgba(34,211,238,0.8)]' : 'bg-pink-500 shadow-[0_0_8px_rgba(236,72,153,0.8)]') 
                                        : 'bg-slate-800 border border-slate-700'
                                }`}
                            />
                        ))}
                    </div>
                    <span className={`text-xs font-bold tracking-widest ${isSelf ? 'text-cyan-400' : 'text-pink-500'}`}>
                        {isSelf ? 'YOU' : 'ENEMY'}
                    </span>
                </div>
            );
        };

        // --- Main App ---

        const App = () => {
            const [peer, setPeer] = useState(null);
            const [conn, setConn] = useState(null);
            const [myId, setMyId] = useState('');
            const [targetId, setTargetId] = useState('');
            
            const [gameState, setGameState] = useState('lobby'); // lobby, setup, playing, result
            const [statusMsg, setStatusMsg] = useState('');
            const [isConnecting, setIsConnecting] = useState(false);
            const isConnectingRef = useRef(false);
            const [peerError, setPeerError] = useState(null);

            // Setup
            const [ngWords, setNgWords] = useState({ 3: '', 2: '', 1: '' });
            const [opponentReady, setOpponentReady] = useState(false);
            const [iAmReady, setIAmReady] = useState(false);

            // Game
            const [history, setHistory] = useState([]);
            const [currentTurn, setCurrentTurn] = useState('host');
            const [role, setRole] = useState(null); // 'host' or 'guest'
            const [myScore, setMyScore] = useState(0); // Actually Damage Taken (0-3)
            const [oppScore, setOppScore] = useState(0);
            const [timer, setTimer] = useState(15);
            const [inputWord, setInputWord] = useState('');
            const [lastChar, setLastChar] = useState('');
            const [shake, setShake] = useState(false); // For damage animation

            const timerRef = useRef(null);
            const scrollRef = useRef(null);
            const checkTimeoutRef = useRef(null);

            // --- Refs for Stale Closure Fix ---
            // 通信ハンドラ内で最新のStateを参照するためのRefs
            const stateRef = useRef({
                ngWords,
                history,
                role,
                myScore,
                oppScore,
                currentTurn
            });

            // Update ref on every render
            useEffect(() => {
                stateRef.current = {
                    ngWords,
                    history,
                    role,
                    myScore,
                    oppScore,
                    currentTurn
                };
            }, [ngWords, history, role, myScore, oppScore, currentTurn]);

            // --- Effects & Logic ---

            const setConnectingState = (state) => {
                setIsConnecting(state);
                isConnectingRef.current = state;
            };

            // Init Peer
            useEffect(() => {
                const initPeer = (retryCount = 0) => {
                    if (retryCount > 3) {
                        setPeerError("ID生成エラー。再読み込みしてください。");
                        return;
                    }
                    const shortId = generateShortId();
                    const fullId = "NGW-" + shortId;

                    const newPeer = new Peer(fullId, { 
                        debug: 1, 
                        config: {'iceServers': [{ url: 'stun:stun.l.google.com:19302' }]}
                    }); 
                    
                    newPeer.on('open', () => {
                        setMyId(shortId); 
                        setPeer(newPeer);
                        setPeerError(null);
                    });

                    newPeer.on('connection', (connection) => {
                        setupConnection(connection, 'host');
                    });

                    newPeer.on('error', (err) => {
                         // Ignore non-fatal errors
                        if (err.message && (err.message.includes('stable') || err.message.includes('setRemoteDescription'))) return;
                        
                        console.error("Peer Error:", err);
                        setConnectingState(false);
                        
                        if (err.type === 'unavailable-id') {
                            newPeer.destroy();
                            initPeer(retryCount + 1);
                        } else if (err.type === 'peer-unavailable') {
                            setStatusMsg(`IDが見つかりません: ${targetId}`);
                        } else {
                            // Don't show generic errors in UI
                        }
                    });

                    return newPeer;
                };

                const p = initPeer();
                return () => { if (p && p.destroy) p.destroy(); };
            }, []);

            // Auto-scroll chat
            useEffect(() => {
                if (scrollRef.current) {
                    scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
                }
            }, [history]);

            // Lucide icons
            useEffect(() => {
                if (window.lucide) window.lucide.createIcons();
            });

            // Timer
            useEffect(() => {
                if (gameState === 'playing' && !checkGameOver()) {
                    if (timerRef.current) clearInterval(timerRef.current);
                    setTimer(15);
                    timerRef.current = setInterval(() => {
                        setTimer((prev) => {
                            if (prev <= 1) {
                                clearInterval(timerRef.current);
                                handleTimeOut();
                                return 0;
                            }
                            return prev - 1;
                        });
                    }, 1000);
                }
                return () => clearInterval(timerRef.current);
            }, [currentTurn, gameState]);

            // --- Connection ---

            const setupConnection = (connection, myRole) => {
                if (conn && conn.open) return; 
                setConn(connection);
                setRole(myRole);
                
                connection.on('open', () => {
                    setConnectingState(false);
                    setGameState('setup');
                    setStatusMsg('');
                });

                // ここでRef経由でハンドラを呼ぶことで、常に最新のState/関数にアクセスできるようにする
                // これにより「古いNGワードリストを参照してしまう」などのバグを防ぐ
                connection.on('data', (data) => {
                    handleDataRef.current(data);
                });

                connection.on('close', () => {
                    setPeerError('接続が切れました');
                    setConnectingState(false);
                });
            };

            // 最新のhandleDataを保持するRef
            const handleDataRef = useRef(null);

            // ハンドラの実体
            const handleDataImpl = (data) => {
                switch (data.type) {
                    case 'READY': setOpponentReady(true); break;
                    case 'MOVE': processReceivedWord(data.word); break;
                    case 'RESULT': applyResult(data); break;
                    case 'RESTART': resetGame(false); break;
                }
            };

            // handleDataRefを更新
            useEffect(() => {
                handleDataRef.current = handleDataImpl;
            });

            const joinGame = () => {
                if (!peer || !targetId || isConnectingRef.current) return;
                const fullTargetId = "NGW-" + targetId.trim().toUpperCase();
                
                if (conn) conn.close();
                if (peer.disconnected) peer.reconnect();
                
                setConnectingState(true);
                setStatusMsg('接続中...');

                setTimeout(() => {
                    try {
                        const connection = peer.connect(fullTargetId, { serialization: 'json', reliable: true });
                        setupConnection(connection, 'guest');
                        
                        setTimeout(() => {
                            if (!connection.open && isConnectingRef.current) {
                                setStatusMsg("応答がありません...");
                                setTimeout(() => setConnectingState(false), 2000);
                            }
                        }, 5000);
                    } catch (e) {
                        setConnectingState(false);
                    }
                }, 300);
            };

            // --- Game Logic ---

            const handleReady = () => {
                if (!ngWords[3]) {
                    setStatusMsg('★3pt NGワードは必須です');
                    return;
                }
                setIAmReady(true);
                conn.send({ type: 'READY' });
            };

            // Start Game Trigger
            useEffect(() => {
                if (iAmReady && opponentReady && gameState === 'setup') {
                    setGameState('playing');
                    setLastChar('り'); 
                    setHistory([{ word: 'しりとり', playedBy: 'system', damage: 0 }]);
                    setCurrentTurn('host'); 
                    setStatusMsg('');
                    setMyScore(0);
                    setOppScore(0);
                }
            }, [iAmReady, opponentReady, gameState]);

            const processReceivedWord = (word) => {
                // 最新のStateを参照するためにRefを使用
                const currentNgWords = stateRef.current.ngWords;
                const currentHistory = stateRef.current.history;
                const currentRole = stateRef.current.role;

                let damage = 0;
                let reasons = [];

                if (getLastChar(word) === 'ん') {
                    damage += 3;
                    reasons.push('「ん」がついた (即死)');
                }
                if (word === currentNgWords[3]) { damage += 3; reasons.push(`★3pt NGを踏んだ`); }
                else if (word === currentNgWords[2]) { damage += 2; reasons.push(`★2pt NGを踏んだ`); }
                else if (word === currentNgWords[1]) { damage += 1; reasons.push(`★1pt NGを踏んだ`); }

                if (currentHistory.some(h => h.word === word)) {
                    damage += 1;
                    reasons.push('既出ワード');
                }

                const resultData = {
                    type: 'RESULT',
                    word: word,
                    playedBy: currentRole === 'host' ? 'guest' : 'host', // The OTHER person played this
                    damage: damage,
                    reasons: reasons,
                    nextTurn: currentRole // If guest played, now host's turn
                };

                // 送信に失敗しないかチェック
                if(conn && conn.open) {
                    conn.send(resultData);
                } else {
                    console.error("Connection lost trying to send result");
                }
                applyResult(resultData);
            };

            const handleSendWord = () => {
                const word = inputWord.trim();
                if (!word) return;
                const hira = toHiragana(word);
                
                if (!/^[\u3040-\u309f]+$/.test(hira)) { setStatusMsg('ひらがなのみ有効'); return; }
                if (lastChar && hira.charAt(0) !== lastChar) { setStatusMsg(`「${lastChar}」から開始！`); return; }

                if(conn && conn.open) {
                    setStatusMsg('判定中...'); 
                    conn.send({ type: 'MOVE', word: hira });
                    setInputWord('');

                    // ★安全装置: 5秒経っても結果が返ってこなければリセットする
                    if (checkTimeoutRef.current) clearTimeout(checkTimeoutRef.current);
                    checkTimeoutRef.current = setTimeout(() => {
                         setStatusMsg('通信エラー：再送してください');
                    }, 5000);
                } else {
                    setStatusMsg('接続切れ：再読み込みしてください');
                }
            };

            const handleTimeOut = () => {
                // 自分がターンプレイヤーの場合のみタイムアウト処理を発火
                if (currentTurn === role) {
                    const resultData = {
                        type: 'RESULT',
                        word: '(時間切れ)',
                        playedBy: role,
                        damage: 1,
                        reasons: ['TIME OUT'],
                        nextTurn: role === 'host' ? 'guest' : 'host'
                    };
                    if(conn && conn.open) conn.send(resultData);
                    applyResult(resultData);
                }
            };

            const applyResult = (data) => {
                // ★成功したのでタイムアウトチェックをクリア
                if (checkTimeoutRef.current) clearTimeout(checkTimeoutRef.current);

                // Clear status messages
                setStatusMsg('');

                // Update history
                setHistory(prev => [...prev, data]);

                // Apply damage
                if (data.damage > 0) {
                    triggerShake();
                    // StateRefは読み取り専用なので、SetStateを使用
                    // ここでのroleはクロージャ内の値だが、Component内関数なので最新のはず
                    // しかし念の為 stateRef.current.role を使うのが無難だが、
                    // ReactのsetState関数形式なら安全
                    if (data.playedBy === role) {
                        setMyScore(prev => Math.min(prev + data.damage, 3));
                    } else {
                        setOppScore(prev => Math.min(prev + data.damage, 3));
                    }
                }

                // Next Turn logic
                if (data.word !== '(時間切れ)') {
                    setLastChar(getLastChar(data.word));
                }
                
                if (myScore < 3 && oppScore < 3) {
                     setCurrentTurn(data.nextTurn);
                }
            };

            const checkGameOver = () => myScore >= 3 || oppScore >= 3;

            const triggerShake = () => {
                setShake(true);
                setTimeout(() => setShake(false), 500);
            };

            const resetGame = (sendSignal = true) => {
                if (sendSignal && conn && conn.open) conn.send({ type: 'RESTART' });
                setMyScore(0);
                setOppScore(0);
                setHistory([{ word: 'しりとり', playedBy: 'system', damage: 0 }]);
                setLastChar('り');
                setCurrentTurn('host');
                setGameState('setup');
                setIAmReady(false);
                setOpponentReady(false);
                setNgWords({ 3: '', 2: '', 1: '' });
                setStatusMsg('');
            };

            const copyId = () => {
                navigator.clipboard.writeText(myId);
                setStatusMsg('コピーしました！');
                setTimeout(() => setStatusMsg(''), 2000);
            };

            // --- Renders ---

            // Screen: Lobby
            if (gameState === 'lobby') return (
                <div className="flex flex-col items-center justify-center min-h-screen p-6 space-y-12">
                    <div className="text-center animate-pop">
                        <h1 className="text-6xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-b from-cyan-300 to-blue-600 neon-text" style={{fontFamily: 'Black Ops One'}}>
                            WORD<br/>BATTLE
                        </h1>
                        <p className="text-cyan-200 mt-4 tracking-[0.5em] text-sm uppercase">Next Gen Shiritori</p>
                    </div>

                    <div className="w-full max-w-md space-y-8">
                        {/* Host Section */}
                        <div className="glass-panel p-6 rounded-2xl neon-box border border-cyan-500/30">
                            <h2 className="text-cyan-400 font-bold mb-4 flex items-center gap-2">
                                <i data-lucide="crown" className="w-5 h-5"></i> HOST GAME
                            </h2>
                            <div className="flex gap-2">
                                <div className="flex-1 bg-black/50 rounded-xl flex items-center justify-center text-3xl font-mono tracking-widest text-white border border-cyan-900 h-16">
                                    {myId || <span className="animate-pulse text-xs text-slate-500">INIT...</span>}
                                </div>
                                <Button onClick={copyId} variant="primary" className="h-16 w-16 !p-0">
                                    <i data-lucide="copy"></i>
                                </Button>
                            </div>
                            <p className="text-xs text-slate-500 mt-2 text-center">SHARE THIS ID WITH YOUR RIVAL</p>
                        </div>

                        {/* Guest Section */}
                        <div className="glass-panel p-6 rounded-2xl border border-slate-700">
                            <h2 className="text-pink-500 font-bold mb-4 flex items-center gap-2">
                                <i data-lucide="swords" className="w-5 h-5"></i> JOIN GAME
                            </h2>
                            <div className="flex gap-2">
                                <GameInput 
                                    value={targetId}
                                    onChange={(e) => setTargetId(e.target.value.toUpperCase())}
                                    placeholder="ENTER ID"
                                    disabled={isConnecting}
                                />
                                <Button 
                                    onClick={joinGame} 
                                    disabled={!myId || !targetId || isConnecting}
                                    variant="danger"
                                    className="h-[60px]"
                                >
                                    {isConnecting ? <i data-lucide="loader-2" className="animate-spin"></i> : 'GO'}
                                </Button>
                            </div>
                        </div>
                    </div>

                    {statusMsg && <div className="fixed bottom-10 bg-slate-900/90 text-cyan-400 px-6 py-3 rounded-full border border-cyan-500/50 backdrop-blur">{statusMsg}</div>}
                    {peerError && <div className="fixed top-10 bg-red-900/90 text-white px-6 py-3 rounded-lg border border-red-500 backdrop-blur animate-shake">{peerError} <button onClick={()=>location.reload()} className="underline ml-2">RELOAD</button></div>}
                </div>
            );

            // Screen: Setup
            if (gameState === 'setup') return (
                <div className="flex flex-col items-center justify-center min-h-screen p-4">
                    <div className="w-full max-w-lg space-y-6 animate-pop">
                        <div className="text-center space-y-2">
                            <h2 className="text-3xl font-black text-white italic">TRAP SETUP</h2>
                            <p className="text-slate-400 text-xs tracking-widest">地雷ワードを設定せよ</p>
                        </div>

                        <div className="space-y-4">
                            {[3, 2, 1].map(pt => (
                                <div key={pt} className={`relative p-1 rounded-xl bg-gradient-to-r ${pt===3 ? 'from-red-600 to-pink-600' : pt===2 ? 'from-orange-500 to-yellow-500' : 'from-yellow-400 to-green-500'}`}>
                                    <div className="bg-slate-900 rounded-lg p-3 flex items-center gap-3">
                                        <div className={`font-black text-2xl w-12 text-center ${pt===3 ? 'text-red-500' : pt===2 ? 'text-orange-400' : 'text-yellow-400'}`}>{pt}<span className="text-xs">PT</span></div>
                                        <input 
                                            type="text" 
                                            value={ngWords[pt]}
                                            onChange={(e) => setNgWords({...ngWords, [pt]: toHiragana(e.target.value)})}
                                            placeholder={pt === 3 ? "即死ワード (必須)" : "ダメージワード (任意)"}
                                            className="flex-1 bg-transparent text-white outline-none font-bold placeholder:text-slate-700"
                                        />
                                        {pt===3 && <i data-lucide="skull" className="text-red-500 opacity-50"></i>}
                                    </div>
                                </div>
                            ))}
                        </div>

                        <div className="pt-8">
                            {!iAmReady ? (
                                <Button onClick={handleReady} variant="primary" size="lg" className="w-full neon-box">
                                    BATTLE START
                                </Button>
                            ) : (
                                <div className="text-center space-y-4">
                                    <div className="animate-spin w-12 h-12 border-4 border-cyan-500 border-t-transparent rounded-full mx-auto"></div>
                                    <p className="text-cyan-400 font-bold animate-pulse">WAITING FOR OPPONENT...</p>
                                </div>
                            )}
                            {statusMsg && <p className="text-center text-red-400 mt-4 font-bold">{statusMsg}</p>}
                        </div>
                    </div>
                </div>
            );

            // Screen: Result
            if (checkGameOver()) return (
                <div className="min-h-screen flex flex-col items-center justify-center bg-black p-4 relative overflow-hidden">
                    <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-slate-900 to-black z-0"></div>
                    <div className="z-10 text-center animate-pop space-y-8">
                        {myScore >= 3 ? (
                            // LOSE
                            <>
                                <h1 className="text-8xl md:text-9xl font-black text-slate-800 tracking-tighter scale-150 opacity-20 absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2">DEFEAT</h1>
                                <div className="text-red-500 mb-8 animate-bounce">
                                    <i data-lucide="skull" className="w-32 h-32 mx-auto"></i>
                                </div>
                                <h2 className="text-6xl font-black text-white neon-text-pink mb-4">YOU LOSE</h2>
                                <p className="text-slate-400 font-mono">DAMAGE: {myScore * 33}% / 100%</p>
                            </>
                        ) : (
                            // WIN
                            <>
                                <div className="text-yellow-400 mb-8 animate-bounce">
                                    <i data-lucide="trophy" className="w-32 h-32 mx-auto"></i>
                                </div>
                                <h2 className="text-6xl font-black text-white neon-text mb-4">VICTORY</h2>
                                <p className="text-cyan-400 font-mono">OPPONENT NEUTRALIZED</p>
                            </>
                        )}
                        
                        <div className="pt-10">
                             <Button onClick={() => resetGame(true)} variant="secondary">REMATCH</Button>
                        </div>
                    </div>
                </div>
            );

            // Screen: Game
            const isMyTurn = currentTurn === role;

            return (
                <div className={`flex flex-col h-screen max-w-2xl mx-auto bg-slate-950 relative overflow-hidden ${shake ? 'animate-shake' : ''}`}>
                    
                    {/* Header / HUD */}
                    <div className="p-4 bg-slate-900/80 backdrop-blur border-b border-slate-800 z-10 flex justify-between items-end shadow-lg">
                        {/* Player (Right in chat, but Left in HUD for standard reading?) Let's stick to standard game HUD: P1 Left, P2 Right. Since 'Right' is ME in chat, let's put ME on Right in HUD too to match. */}
                        
                        {/* OPPONENT HUD (Left) */}
                        <LifeBar hp={3 - oppScore} isSelf={false} />

                        {/* TIMER CENTER */}
                        <div className="absolute left-1/2 -translate-x-1/2 top-2 flex flex-col items-center">
                            <div className={`text-4xl font-black font-mono ${timer <= 5 ? 'text-red-500 animate-pulse scale-110' : 'text-slate-200'}`} style={{fontFamily: 'Black Ops One'}}>
                                {timer}
                            </div>
                            <div className="text-[10px] text-slate-500 tracking-widest">SEC</div>
                        </div>

                        {/* SELF HUD (Right) */}
                        <LifeBar hp={3 - myScore} isSelf={true} />
                    </div>

                    {/* Chat Area */}
                    <div className="flex-1 overflow-y-auto p-4 space-y-4 scroll-smooth" ref={scrollRef}>
                        {history.map((h, i) => {
                            if (h.playedBy === 'system') {
                                return (
                                    <div key={i} className="flex justify-center my-4">
                                        <span className="bg-slate-800 text-slate-400 text-xs px-3 py-1 rounded-full border border-slate-700">
                                            {h.word}
                                        </span>
                                    </div>
                                );
                            }

                            const isMine = h.playedBy === role;

                            return (
                                <div key={i} className={`flex flex-col ${isMine ? 'items-end' : 'items-start'} animate-pop`}>
                                    <div className={`chat-bubble ${isMine ? 'mine' : 'opponent'}`}>
                                        <div className="text-lg">{h.word}</div>
                                    </div>
                                    {h.damage > 0 && (
                                        <div className="mt-1 text-red-500 font-bold text-xs flex flex-col items-end">
                                            {h.reasons.map((r, ri) => <span key={ri}>{r}</span>)}
                                            <span className="text-sm">-{h.damage} HP</span>
                                        </div>
                                    )}
                                </div>
                            );
                        })}
                        <div className="h-12"></div> 
                    </div>

                    {/* Footer / Input */}
                    <div className={`p-4 pb-8 transition-colors duration-500 ${isMyTurn ? 'bg-cyan-900/20' : 'bg-slate-900/80'}`}>
                        {/* Turn Status Banner */}
                        <div className="flex justify-between items-center mb-2 px-2">
                            <div className="text-xs text-slate-400">
                                Last: <span className="text-white font-bold text-xl ml-1">{lastChar || '-'}</span>
                            </div>
                            <div className={`text-sm font-bold tracking-widest uppercase ${isMyTurn ? 'text-cyan-400 animate-pulse' : 'text-slate-500'}`}>
                                {isMyTurn ? 'YOUR TURN' : 'OPPONENT TURN'}
                            </div>
                        </div>

                        {/* Input Group */}
                        <div className="flex gap-2 relative">
                            <GameInput 
                                value={inputWord}
                                onChange={(e) => {
                                    setStatusMsg(''); // User typing clears old status
                                    setInputWord(toHiragana(e.target.value));
                                }}
                                onKeyDown={(e) => e.key === 'Enter' && isMyTurn && handleSendWord()}
                                placeholder={isMyTurn ? `「${lastChar}」から` : "待機中..."}
                                disabled={!isMyTurn}
                                autoFocus
                            />
                            <Button 
                                onClick={handleSendWord} 
                                disabled={!isMyTurn || !inputWord}
                                variant={isMyTurn ? "primary" : "secondary"}
                                className="w-20"
                            >
                                <i data-lucide="send"></i>
                            </Button>

                            {/* Status Overlay for Input */}
                            {statusMsg && (
                                <div className="absolute -top-10 left-0 right-0 text-center">
                                    <span className="bg-black/80 text-cyan-400 text-xs font-bold px-3 py-1 rounded-full border border-cyan-500/50">
                                        {statusMsg}
                                    </span>
                                </div>
                            )}
                        </div>
                    </div>

                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
