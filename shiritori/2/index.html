<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Ê¨°‰∏ñ‰ª£„Åó„Çä„Å®„Çä - NEXUS</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Mochiy+Pop+One&family=Zen+Maru+Gothic:wght@500;700;900&display=swap');
        
        :root {
            /* Nintendo-ish Pop Colors */
            --c-p1: #007AFF; /* Vivid Blue */
            --c-p2: #FF2D55; /* Vivid Pink */
            --c-accent: #FFCC00; /* Coin Yellow */
            --c-bg: #F2F2F7;
            --c-text: #1C1C1E;
            --safe-top: env(safe-area-inset-top, 20px);
            --safe-bottom: env(safe-area-inset-bottom, 20px);
        }

        body {
            font-family: 'Zen Maru Gothic', sans-serif;
            background-color: var(--c-bg);
            color: var(--c-text);
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none;
            overscroll-behavior: none;
        }

        /* --- UI COMPONENTS --- */
        .font-pop { font-family: 'Mochiy Pop One', sans-serif; }

        .pop-btn {
            transition: transform 0.1s cubic-bezier(0.34, 1.56, 0.64, 1), box-shadow 0.1s;
            box-shadow: 0 4px 0 rgba(0,0,0,0.15);
            transform: translateY(0);
            position: relative;
            overflow: hidden;
        }
        .pop-btn:active:not(:disabled) {
            transform: translateY(4px);
            box-shadow: 0 0 0 rgba(0,0,0,0.15);
        }
        .pop-btn:disabled {
            opacity: 0.5; cursor: not-allowed; box-shadow: none;
            transform: translateY(4px); filter: grayscale(100%);
        }

        .pop-card {
            background: white;
            border-radius: 1.5rem;
            border: 4px solid #fff;
            box-shadow: 0 8px 20px rgba(0,0,0,0.08);
        }

        .pop-input {
            border: 3px solid #E5E5EA;
            border-radius: 1rem;
            transition: all 0.2s;
            font-family: 'Zen Maru Gothic', sans-serif;
            font-weight: 900;
            font-size: 16px; 
            color: #333;
            background: #F2F2F7;
        }
        .pop-input:focus {
            outline: none;
            border-color: var(--c-p1);
            background-color: #fff;
            box-shadow: 0 0 0 4px rgba(0,122,255, 0.15);
        }

        /* --- ANIMATIONS --- */
        @keyframes bg-slide {
            0% { background-position: 0 0; }
            100% { background-position: 40px 40px; }
        }
        .bg-pattern {
            background-color: #F2F2F7;
            background-image: 
                radial-gradient(#C7C7CC 2px, transparent 2.5px);
            background-size: 20px 20px;
            animation: bg-slide 20s linear infinite;
        }

        @keyframes pop-in {
            0% { transform: scale(0.8); opacity: 0; }
            60% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-pop-in { animation: pop-in 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }

        @keyframes bounce-title {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        .animate-title { animation: bounce-title 3s infinite ease-in-out; }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-6px) rotate(-3deg); }
            40%, 80% { transform: translateX(6px) rotate(3deg); }
        }
        .animate-shake { animation: shake 0.4s cubic-bezier(.36,.07,.19,.97) both; }

        /* 3D Coin */
        .coin-scene { perspective: 1000px; }
        .coin-3d {
            width: 100%; height: 100%;
            transform-style: preserve-3d;
            /* Animation controlled via inline styles */
        }
        .coin-face {
            position: absolute; width: 100%; height: 100%;
            backface-visibility: hidden;
            display: flex; align-items: center; justify-content: center;
            border-radius: 50%;
            border: 8px solid white;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.1), 0 5px 15px rgba(0,0,0,0.2);
        }

        /* Utilities */
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .safe-top-padding { padding-top: max(20px, var(--safe-top)); }
        .safe-bottom-padding { padding-bottom: max(20px, var(--safe-bottom)); }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- AUDIO SYSTEM V5 (BGM + SE) ---
        const AudioSys = {
            ctx: null,
            bgmNode: null,
            isPlaying: false,
            volume: 0.3,
            
            init: () => {
                if (!AudioSys.ctx) {
                    AudioSys.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (AudioSys.ctx.state === 'suspended') AudioSys.ctx.resume();
            },

            playSE: (type) => {
                if (!AudioSys.ctx) return;
                const t = AudioSys.ctx.currentTime;
                const osc = AudioSys.ctx.createOscillator();
                const gain = AudioSys.ctx.createGain();
                osc.connect(gain);
                gain.connect(AudioSys.ctx.destination);

                switch(type) {
                    case 'tap':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(600, t);
                        osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
                        gain.gain.setValueAtTime(0.2, t);
                        gain.gain.linearRampToValueAtTime(0, t + 0.1);
                        osc.start(t); osc.stop(t + 0.1);
                        break;
                    case 'confirm': // "Ping!"
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(880, t); 
                        osc.frequency.linearRampToValueAtTime(1760, t + 0.1);
                        gain.gain.setValueAtTime(0.15, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                        osc.start(t); osc.stop(t + 0.4);
                        break;
                    case 'error': // "Buu!"
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(150, t);
                        osc.frequency.linearRampToValueAtTime(100, t + 0.2);
                        gain.gain.setValueAtTime(0.2, t);
                        gain.gain.linearRampToValueAtTime(0, t + 0.2);
                        osc.start(t); osc.stop(t + 0.2);
                        break;
                    case 'turn': // "Piko-n!"
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(987, t); 
                        osc.frequency.setValueAtTime(1318, t + 0.1); 
                        gain.gain.setValueAtTime(0.1, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.4);
                        osc.start(t); osc.stop(t + 0.4);
                        break;
                    case 'damage': // Heavy hit
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(100, t);
                        osc.frequency.exponentialRampToValueAtTime(30, t + 0.2);
                        gain.gain.setValueAtTime(0.3, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
                        osc.start(t); osc.stop(t + 0.3);
                        break;
                    case 'win': // Fanfare
                         [523.25, 659.25, 783.99, 1046.50, 1318.51].forEach((f, i) => {
                            const o = AudioSys.ctx.createOscillator();
                            const g = AudioSys.ctx.createGain();
                            o.type = 'triangle'; o.connect(g); g.connect(AudioSys.ctx.destination);
                            o.frequency.value = f;
                            g.gain.setValueAtTime(0.1, t + i*0.1);
                            g.gain.linearRampToValueAtTime(0, t + i*0.1 + 0.3);
                            o.start(t + i*0.1); o.stop(t + i*0.1 + 0.3);
                        });
                        break;
                }
            },

            startBGM: () => {
                if (AudioSys.isPlaying || !AudioSys.ctx) return;
                AudioSys.isPlaying = true;
                
                // Simple Sequencer
                let step = 0;
                const tempo = 0.2; // sec per note
                
                const playStep = () => {
                    if (!AudioSys.isPlaying) return;
                    const t = AudioSys.ctx.currentTime;
                    // Bass
                    const bassOsc = AudioSys.ctx.createOscillator();
                    const bassGain = AudioSys.ctx.createGain();
                    bassOsc.connect(bassGain); bassGain.connect(AudioSys.ctx.destination);
                    bassOsc.type = 'triangle';
                    
                    // Simple C Major Progression
                    const root = (Math.floor(step / 8) % 2 === 0) ? 261.63 : 196.00; // C4 then G3
                    bassOsc.frequency.value = (step % 2 === 0) ? root : root * 1.5; 
                    
                    bassGain.gain.setValueAtTime(0.05 * AudioSys.volume, t);
                    bassGain.gain.exponentialRampToValueAtTime(0.001, t + tempo);
                    bassOsc.start(t); bassOsc.stop(t + tempo);

                    // Melody (every 2 steps)
                    if (step % 2 === 0) {
                         const melOsc = AudioSys.ctx.createOscillator();
                         const melGain = AudioSys.ctx.createGain();
                         melOsc.connect(melGain); melGain.connect(AudioSys.ctx.destination);
                         melOsc.type = 'sine';
                         
                         // Cute Arpeggio
                         const notes = [523.25, 659.25, 783.99, 1046.50];
                         const note = notes[(step / 2) % 4];
                         
                         melOsc.frequency.value = note;
                         melGain.gain.setValueAtTime(0.03 * AudioSys.volume, t);
                         melGain.gain.exponentialRampToValueAtTime(0.001, t + tempo * 2);
                         melOsc.start(t); melOsc.stop(t + tempo * 2);
                    }

                    step++;
                    AudioSys.bgmNode = setTimeout(playStep, tempo * 1000);
                };
                playStep();
            },

            stopBGM: () => {
                AudioSys.isPlaying = false;
                if (AudioSys.bgmNode) clearTimeout(AudioSys.bgmNode);
            }
        };

        // --- CONSTANTS ---
        const SAMPLE_TOPICS = ["„Ç¢„Éã„É°„Ç≠„É£„É©", "Â≠¶Ê†°„Å´„ÅÇ„Çã„ÇÇ„ÅÆ", "„Ç≥„É≥„Éì„Éã„ÅÆÂïÜÂìÅ", "4ÊñáÂ≠ó„ÅÆË®ÄËëâ", "Á∑ëËâ≤„ÅÆ„ÇÇ„ÅÆ", "Ê≠¥Âè≤‰∏ä„ÅÆ‰∫∫Áâ©", "Ëµ§„ÅÑ„ÇÇ„ÅÆ", "‰∏∏„ÅÑ„ÇÇ„ÅÆ", "ÂõΩÂêç„ÉªÂú∞Âêç", "ÂãïÁâ©", "Ê∞¥„ÅÆ‰∏≠„ÅÆÁîü„ÅçÁâ©", "ÂÜ¨„Å´Èñ¢ÈÄ£„Åô„Çã„ÇÇ„ÅÆ", "„Ç≠„ÉÉ„ÉÅ„É≥„Å´„ÅÇ„Çã„ÇÇ„ÅÆ", "„Çπ„Éù„Éº„ÉÑ", "ËÅ∑Ê•≠", "„Ç´„Çø„Ç´„ÉäË™û", "3ÊñáÂ≠ó„ÅÆË®ÄËëâ", "Áîò„ÅÑ„ÇÇ„ÅÆ", "ÂÜ∑„Åü„ÅÑ„ÇÇ„ÅÆ", "Á©∫„ÇíÈ£õ„Å∂„ÇÇ„ÅÆ", "ÈªÑËâ≤„ÅÑ„ÇÇ„ÅÆ", "ÂÆ∂„Å´„ÅÇ„Çã„ÇÇ„ÅÆ", "Êº¢Â≠ó2ÊñáÂ≠ó", "Â§è„Å´Èñ¢ÈÄ£„Åô„Çã„ÇÇ„ÅÆ"];
        const MAX_HP = 5;
        const TIMER_SETUP = 60; 
        const TIMER_GAME = 60; 
        const TURN_ANIM_DURATION = 2000;
        const HIRAGANA_CHARS = "„ÅÇ„ÅÑ„ÅÜ„Åà„Åä„Åã„Åç„Åè„Åë„Åì„Åï„Åó„Åô„Åõ„Åù„Åü„Å°„Å§„Å¶„Å®„Å™„Å´„Å¨„Å≠„ÅÆ„ÅØ„Å≤„Åµ„Å∏„Åª„Åæ„Åø„ÇÄ„ÇÅ„ÇÇ„ÇÑ„ÇÜ„Çà„Çâ„Çä„Çã„Çå„Çç„Çè„Åå„Åé„Åê„Åí„Åî„Åñ„Åò„Åö„Åú„Åû„Å†„Å¢„Å•„Åß„Å©„Å∞„Å≥„Å∂„Åπ„Åº„Å±„Å¥„Å∑„Å∫„ÅΩ";

        // --- UTILS ---
        const getRandomChar = () => HIRAGANA_CHARS[Math.floor(Math.random() * HIRAGANA_CHARS.length)];
        const generateId = () => Math.random().toString(36).substring(2, 6).toUpperCase();
        const toHiragana = (str) => str.replace(/[\u30a1-\u30f6]/g, m => String.fromCharCode(m.charCodeAt(0) - 0x60));
        const getLastChar = (w) => {
            if(!w) return '';
            const last = w.slice(-1);
            const map = {'„ÅÅ':'„ÅÇ','„ÅÉ':'„ÅÑ','„ÅÖ':'„ÅÜ','„Åá':'„Åà','„Åâ':'„Åä','„Å£':'„Å§','„ÇÉ':'„ÇÑ','„ÇÖ':'„ÇÜ','„Çá':'„Çà','„Çé':'„Çè'};
            if(map[last]) return map[last];
            if(last === '„Éº') { const prev = w.slice(-2, -1); return map[prev] || prev; }
            return last;
        };

        // --- COMPONENTS ---
        const Button = ({ onClick, children, className="", disabled=false, variant="primary", icon, fullWidth=false }) => {
            const handleInteract = () => {
                if(!disabled) { AudioSys.init(); AudioSys.playSE(variant === 'danger' ? 'confirm' : 'tap'); onClick && onClick(); }
            };
            const styles = {
                primary: "bg-blue-500 text-white hover:bg-blue-600",
                danger: "bg-pink-500 text-white hover:bg-pink-600",
                ghost: "bg-slate-200 text-slate-700 hover:bg-slate-300"
            };
            return (
                <button onClick={handleInteract} disabled={disabled} className={`pop-btn rounded-2xl font-black tracking-wider flex items-center justify-center gap-2 py-3 px-6 ${styles[variant]} ${fullWidth ? 'w-full' : ''} ${className}`}>
                    {icon && <i data-lucide={icon} className="w-5 h-5"></i>}<span>{children}</span>
                </button>
            );
        };

        const Toast = ({ msg }) => (
            <div className="fixed top-12 left-0 right-0 z-[100] flex justify-center pointer-events-none animate-pop-in">
                <div className="bg-slate-800 text-white px-6 py-3 rounded-full font-bold shadow-xl border-4 border-white flex items-center gap-2 text-sm">
                    <i data-lucide="info" className="w-4 h-4"></i>{msg}
                </div>
            </div>
        );

        // --- MAIN APP ---
        const App = () => {
            // Net
            const [peer, setPeer] = useState(null);
            const [conn, setConn] = useState(null);
            const [myId, setMyId] = useState('');
            const [targetId, setTargetId] = useState('');
            const [isHost, setIsHost] = useState(false);
            const [userName, setUserName] = useState('');
            const [oppName, setOppName] = useState('RIVAL');
            
            // Audio
            const [isMuted, setIsMuted] = useState(false);

            // Game State
            const [phase, setPhase] = useState('lobby'); 
            const [error, setError] = useState('');
            const [damageAlert, setDamageAlert] = useState(null);
            const [turnNotify, setTurnNotify] = useState(null); 
            const [myTopic, setMyTopic] = useState('');
            const [oppTopic, setOppTopic] = useState('');
            const [isMyTopicConfirmed, setIsMyTopicConfirmed] = useState(false);
            const [isOppTopicConfirmed, setIsOppTopicConfirmed] = useState(false);
            const [rouletteDisplay, setRouletteDisplay] = useState('');
            const [selectedTopic, setSelectedTopic] = useState(null);
            const [ngWords, setNgWords] = useState({ high: '', mid: '', low: '' });
            const [oppNgReady, setOppNgReady] = useState(false);
            
            const [coinResult, setCoinResult] = useState(null);
            const [coinStyle, setCoinStyle] = useState({});

            const [history, setHistory] = useState([]);
            const [turn, setTurn] = useState('host');
            const [myHp, setMyHp] = useState(MAX_HP);
            const [oppHp, setOppHp] = useState(MAX_HP);
            const [input, setInput] = useState('');
            const [lastChar, setLastChar] = useState('');
            const [initialChar, setInitialChar] = useState(''); 
            const [displayTimer, setDisplayTimer] = useState(0); 
            const [phaseStartTime, setPhaseStartTime] = useState(0); 
            const [turnStartTime, setTurnStartTime] = useState(0); 
            const [isInputLocked, setIsInputLocked] = useState(false);
            const [isOpponentTyping, setIsOpponentTyping] = useState(false);

            const stateRef = useRef({ phase, turn, myHp, oppHp, history, isHost, myTopic, oppTopic, ngWords, oppNgReady, userName, turnStartTime, phaseStartTime, isMyTopicConfirmed, isOppTopicConfirmed, initialChar, isInputLocked });
            const connRef = useRef(null); 
            const scrollRef = useRef(null);
            const loopRef = useRef(null);
            const processingTimeout = useRef(false);

            // Sync Ref
            useEffect(() => { stateRef.current = { phase, turn, myHp, oppHp, history, isHost, myTopic, oppTopic, ngWords, oppNgReady, userName, turnStartTime, phaseStartTime, isMyTopicConfirmed, isOppTopicConfirmed, initialChar, isInputLocked }; }, [phase, turn, myHp, oppHp, history, isHost, myTopic, oppTopic, ngWords, oppNgReady, userName, turnStartTime, phaseStartTime, isMyTopicConfirmed, isOppTopicConfirmed, initialChar, isInputLocked]);
            
            // Persistence
            useEffect(() => { const saved = localStorage.getItem('nwb_username'); if(saved) setUserName(saved); }, []);
            useEffect(() => { if(userName) localStorage.setItem('nwb_username', userName); }, [userName]);
            
            // Audio Toggle
            const toggleMute = () => {
                if (isMuted) { setIsMuted(false); AudioSys.volume = 0.3; AudioSys.startBGM(); }
                else { setIsMuted(true); AudioSys.volume = 0; AudioSys.stopBGM(); }
            };

            // Coin Animation
            useEffect(() => {
                if (phase === 'coin' && coinResult) {
                    setCoinStyle({ transform: 'rotateY(0deg)', transition: 'none' });
                    // Force reflow
                    setTimeout(() => {
                        const deg = coinResult === (isHost ? 'host' : 'guest') ? 3600 : 3780;
                        setCoinStyle({ transform: `rotateY(${deg}deg)`, transition: 'transform 3.5s cubic-bezier(0.15, 0.9, 0.3, 1.1)' });
                    }, 50);
                }
            }, [phase, coinResult, isHost]);

            // Init
            useEffect(() => {
                if(window.lucide) window.lucide.createIcons();
                const id = generateId();
                const p = new Peer(`KB-${id}`);
                p.on('open', () => { setMyId(id); setPeer(p); });
                p.on('connection', c => setupConn(c, true));
                p.on('error', e => showError('Êé•Á∂ö„Ç®„É©„Éº'));
                return () => p.destroy();
            }, []);

            useEffect(() => {
                const loop = () => {
                    const s = stateRef.current;
                    const now = Date.now();
                    let targetTime = 0;
                    let duration = 0;
                    if (s.phase === 'topic_input' || s.phase === 'ng_input') { targetTime = s.phaseStartTime; duration = TIMER_SETUP; }
                    else if (s.phase === 'playing' && s.turnStartTime > 0) { targetTime = s.turnStartTime; duration = TIMER_GAME; }

                    if (targetTime > 0) {
                        if (s.phase === 'playing' && now < targetTime) { setDisplayTimer(TIMER_GAME); setIsInputLocked(true); } 
                        else {
                            const elapsedSec = (now - targetTime) / 1000;
                            const remain = Math.max(0, Math.ceil(duration - elapsedSec));
                            setDisplayTimer(remain);
                            setIsInputLocked(false);
                            if (s.isHost && remain <= 0 && !processingTimeout.current) {
                                if (s.phase === 'playing') handleTimeout();
                                else if (s.phase === 'ng_input') forceStartGame();
                                else if (s.phase === 'topic_input') forceSubmitTopic();
                            }
                        }
                    }
                    loopRef.current = requestAnimationFrame(loop);
                };
                loopRef.current = requestAnimationFrame(loop);
                return () => cancelAnimationFrame(loopRef.current);
            }, []);

            const connect = () => { 
                if(!targetId || !peer) return; 
                AudioSys.init(); AudioSys.playSE('confirm');
                if(!isMuted) AudioSys.startBGM();
                setupConn(peer.connect(`KB-${targetId.toUpperCase()}`), false); 
            };
            const setupConn = (c, amHost) => {
                setConn(c); connRef.current = c; setIsHost(amHost);
                c.on('open', () => {
                    send({ type: 'NAME_SYNC', name: stateRef.current.userName || 'PLAYER' });
                    setPhase('vs');
                    setTimeout(() => startPhase('topic_input'), 4000);
                });
                c.on('data', handleData);
                c.on('close', () => { showError('ÈÄö‰ø°„ÅåÂàá„Çå„Åæ„Åó„Åü'); resetGame(); });
            };
            const send = (data) => { if(connRef.current?.open) connRef.current.send(data); };
            const startPhase = (newPhase) => {
                const now = Date.now();
                setPhase(newPhase); setPhaseStartTime(now);
                if (stateRef.current.isHost) send({ type: 'PHASE_CHANGE', phase: newPhase, startTime: now });
            };

            const handleData = (data) => {
                const s = stateRef.current;
                switch(data.type) {
                    case 'NAME_SYNC': setOppName(data.name || 'RIVAL'); if(s.isHost) send({ type: 'NAME_SYNC', name: s.userName || 'PLAYER' }); break;
                    case 'PHASE_CHANGE': setPhase(data.phase); setPhaseStartTime(data.startTime); break;
                    case 'TOPIC_CONFIRM': setOppTopic(data.topic); setIsOppTopicConfirmed(true); if (s.isHost && s.isMyTopicConfirmed) startRoulette(s.myTopic, data.topic); break;
                    case 'ROULETTE_START': setOppTopic(data.hostTopic); playRouletteAnimation(data.candidates, data.winner); break;
                    case 'NG_READY': setOppNgReady(true); if(s.isHost && s.phase === 'ng_wait') startCoinToss(); break;
                    case 'FORCE_NG_COMPLETE': setOppNgReady(true); if(s.isHost) startCoinToss(); break;
                    case 'COIN_TOSS_START':
                        setCoinResult(data.result); setLastChar(data.initialChar); setInitialChar(data.initialChar); setPhase('coin');
                        setTimeout(() => { 
                            setPhase('playing'); setTurn(data.result); setHistory([]); 
                            setTurnStartTime(Date.now() + TURN_ANIM_DURATION);
                            triggerTurnAnim(data.result === (isHost ? 'host' : 'guest') ? 'me' : 'rival', 0);
                        }, 4000);
                        break;
                    case 'MOVE': setIsOpponentTyping(false); receiveMove(data.word); break;
                    case 'TURN_CHANGE':
                        processingTimeout.current = false;
                        setTurn(data.nextTurn); setTurnStartTime(data.startTime);
                        // Force HP sync from host if needed, but here we trust symmetric logic mostly.
                        // Ideally we should sync HP here, but current logic relies on events.
                        triggerTurnAnim(data.nextTurn === (isHost ? 'host' : 'guest') ? 'me' : 'rival', data.delay);
                        if (data.nextTurn !== (isHost ? 'host' : 'guest')) setInput('');
                        break;
                    case 'DAMAGE_REPORT': 
                        applyDamage('me', data.amount, data.reason); 
                        break;
                    case 'TIMEOUT_PENALTY':
                        processingTimeout.current = false;
                        setMyHp(data.newHostHp); setOppHp(data.newGuestHp); // Sync from host
                        setTurn(data.nextTurn); setTurnStartTime(data.startTime);
                        setHistory(prev => [...prev, { type: 'timeout', owner: data.victim }]);
                        triggerTurnAnim(data.nextTurn === (isHost ? 'host' : 'guest') ? 'me' : 'rival', 3000);
                        break;
                    case 'GAME_OVER': // Reliable End Game
                         setPhase('result');
                         if (data.winnerId === (isHost ? 'host' : 'guest')) {
                             AudioSys.playSE('win');
                         }
                         setMyHp(data.finalMyHp); setOppHp(data.finalOppHp);
                         break;
                    case 'TYPING': setIsOpponentTyping(data.isTyping); break;
                    case 'REMATCH': resetGame(); break;
                }
            };

            const triggerTurnAnim = (who, delay) => {
                setTimeout(() => { setTurnNotify(who); AudioSys.playSE('turn'); setTimeout(() => setTurnNotify(null), 2000); }, delay);
            };

            // --- GAME LOGIC ---
            const submitTopic = () => {
                if(!myTopic) return showError("„ÅäÈ°å„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
                setIsMyTopicConfirmed(true); send({ type: 'TOPIC_CONFIRM', topic: myTopic });
                if (isHost && stateRef.current.isOppTopicConfirmed) startRoulette(myTopic, stateRef.current.oppTopic);
            };
            const forceSubmitTopic = () => {
                const s = stateRef.current;
                let myT = s.myTopic || SAMPLE_TOPICS[Math.floor(Math.random()*SAMPLE_TOPICS.length)];
                let oppT = s.oppTopic || SAMPLE_TOPICS[Math.floor(Math.random()*SAMPLE_TOPICS.length)];
                if (!s.isMyTopicConfirmed) { setMyTopic(myT); setIsMyTopicConfirmed(true); send({ type: 'TOPIC_CONFIRM', topic: myT }); }
                startRoulette(myT, oppT);
            };
            const startRoulette = (hostT, guestT) => {
                const isHostChosen = Math.random() > 0.5;
                const winner = isHostChosen ? { text: hostT, owner: 'host' } : { text: guestT, owner: 'guest' };
                playRouletteAnimation([hostT, guestT], winner);
                send({ type: 'ROULETTE_START', candidates: [hostT, guestT], winner, hostTopic: hostT });
            };
            const playRouletteAnimation = (candidates, winner) => {
                setPhase('roulette'); let count = 0;
                const spin = () => {
                    setRouletteDisplay(candidates[count % 2]); count++;
                    if(count < 20) setTimeout(spin, 50 + count * 10);
                    else {
                        setRouletteDisplay(winner.text); setSelectedTopic(winner); AudioSys.playSE('confirm');
                        setTimeout(() => startPhase('ng_input'), 2500);
                    }
                };
                spin();
            };
            const submitNg = () => {
                const words = [ngWords.high, ngWords.mid, ngWords.low];
                if(words.some(w => w.slice(-1) === '„Çì')) return showError("„Äå„Çì„Äç„ÅßÁµÇ„Çè„ÇãË®ÄËëâ„ÅØÁ¶ÅÊ≠¢„Åß„Åô");
                if(words.some(w => w && !/^[\u3040-\u309f„Éº]+$/.test(w))) return showError("„Å≤„Çâ„Åå„Å™„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ");
                setPhase('ng_wait'); send({ type: 'NG_READY' });
                if(isHost && oppNgReady) startCoinToss();
            };
            const forceStartGame = () => { if (stateRef.current.phase === 'ng_input') { setNgWords({high:'', mid:'', low:''}); setPhase('ng_wait'); send({ type: 'FORCE_NG_COMPLETE' }); startCoinToss(); } };
            const startCoinToss = () => {
                const initialChar = getRandomChar();
                const firstPlayer = Math.random() > 0.5 ? 'host' : 'guest';
                send({ type: 'COIN_TOSS_START', result: firstPlayer, initialChar });
                setCoinResult(firstPlayer); setLastChar(initialChar); setInitialChar(initialChar); setPhase('coin');
                setTimeout(() => {
                    setPhase('playing'); setTurn(firstPlayer); setHistory([]); 
                    setTurnStartTime(Date.now() + TURN_ANIM_DURATION);
                    triggerTurnAnim(firstPlayer === 'host' ? 'me' : 'rival', 0);
                }, 4000);
            };

            const checkGameOver = (newMyHp, newOppHp) => {
                // Self-check: If I died, I declare game over to ensure sync
                if (newMyHp <= 0) {
                    const winnerId = isHost ? 'guest' : 'host';
                    setPhase('result');
                    // Send Game Over Signal
                    send({ 
                        type: 'GAME_OVER', 
                        winnerId: winnerId,
                        finalMyHp: newOppHp, // Sent as "Your HP" to opponent
                        finalOppHp: newMyHp  // Sent as "Opp HP" to opponent
                    });
                }
            };

            const submitWord = () => {
                if(!input) return;
                const hira = toHiragana(input);
                if (!/^[\u3040-\u309f„Éº]+$/.test(hira)) return showError('„Å≤„Çâ„Åå„Å™„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
                if (lastChar && hira[0] !== lastChar) return showError(`„Äå${lastChar}„Äç„Åã„ÇâÂßã„ÇÅ„Å¶„Åè„Å†„Åï„ÅÑ`);
                if (history.some(h => h.word === hira)) return showError('Êó¢Âá∫„ÉØ„Éº„Éâ„Åß„Åô');
                if(hira.slice(-1) === '„Çì') {
                    // Suicide
                    const dmg = MAX_HP;
                    const nextHp = Math.max(0, myHp - dmg);
                    setMyHp(nextHp);
                    setHistory([...history, { word: hira, owner: isHost?'host':'guest', damage: dmg }]);
                    send({ type: 'MOVE', word: hira }); 
                    send({ type: 'DAMAGE_REPORT', amount: dmg, reason: 'Ëá™ÁàÜÔºÅ' });
                    checkGameOver(nextHp, oppHp); // I check if I died
                    return;
                }
                setHistory([...history, { word: hira, owner: isHost?'host':'guest', damage: 0 }]);
                setInput(''); send({ type: 'MOVE', word: hira });
                setLastChar(getLastChar(hira)); changeTurnInternal(isHost?'guest':'host', false);
            };

            const receiveMove = (word) => {
                const s = stateRef.current;
                // Check TRAP
                let dmg = 0; let reason = '';
                if(word === s.ngWords.high) { dmg = 3; reason = 'NG„ÉØ„Éº„Éâ (3„ÉÄ„É°„Éº„Ç∏)!'; }
                else if(word === s.ngWords.mid) { dmg = 2; reason = 'NG„ÉØ„Éº„Éâ (2„ÉÄ„É°„Éº„Ç∏)!'; }
                else if(word === s.ngWords.low) { dmg = 1; reason = 'NG„ÉØ„Éº„Éâ (1„ÉÄ„É°„Éº„Ç∏)!'; }
                
                // Note: The 'Suicide' case ("„Çì") is handled by Sender applying damage to self.
                // Receiver just updates history. 
                if(word.slice(-1) === '„Çì') { 
                    dmg = MAX_HP; reason = 'Ëá™ÁàÜÔºÅ'; 
                    // The sender will tell me they took damage via DAMAGE_REPORT, so we don't apply damage here to opponent locally to avoid double counting if logic differs.
                    // BUT, for display, we need to show the HIT.
                }

                setHistory(prev => [...prev, { word, owner: !s.isHost ? 'host' : 'guest', damage: dmg }]);
                setLastChar(getLastChar(word));
                
                // If I triggered damage to Opponent (Trap), I tell them.
                const isTrap = (dmg > 0 && word.slice(-1) !== '„Çì');
                if(isTrap) { 
                    // I detected opponent stepped on my trap.
                    // I send them a damage report. 
                    // Wait, standard design: I take damage locally? No, I tell them they took damage.
                    // The previous logic: "applyDamage('opp', ...)" meant I update my view of their HP.
                    // AND I send DAMAGE_REPORT? No, the previous code sent DAMAGE_REPORT only if *I* took damage?
                    // Let's look at previous: "if(hasDamage) { applyDamage('opp', ...); send({ type: 'DAMAGE_REPORT', ... }) }"
                    // This means I (Receiver) update my UI AND tell Sender "You took damage".
                    
                    const nextOppHp = Math.max(0, s.oppHp - dmg);
                    setOppHp(nextOppHp); // Update local view
                    setDamageAlert({ target: 'opp', amount: dmg, reason });
                    AudioSys.playSE('damage'); setTimeout(() => setDamageAlert(null), 2000);
                    
                    send({ type: 'DAMAGE_REPORT', amount: dmg, reason }); // Tell them
                }

                if (s.isHost) changeTurnInternal(s.isHost ? 'host' : 'guest', isTrap);
                else { 
                    setTurn(s.isHost ? 'host' : 'guest'); 
                    triggerTurnAnim(s.isHost ? 'me' : 'rival', isTrap ? 3000 : 0); 
                }
            };

            const applyDamage = (target, amount, msg) => {
                // I received a report that I (or opp) took damage
                setDamageAlert({ target, amount, reason: msg }); 
                AudioSys.playSE('damage'); 
                setTimeout(() => setDamageAlert(null), 2000);

                let nextVal;
                if (target === 'me') {
                    nextVal = Math.max(0, stateRef.current.myHp - amount);
                    setMyHp(nextVal);
                    // Check if I died from this external report
                    checkGameOver(nextVal, stateRef.current.oppHp);
                } else {
                    nextVal = Math.max(0, stateRef.current.oppHp - amount);
                    setOppHp(nextVal);
                }

                setHistory(prev => {
                    if(prev.length === 0) return prev;
                    const last = prev[prev.length - 1];
                    // Retroactively add damage tag to the last word if it matches the reason
                    if((msg.includes('NG') || msg.includes('Ëá™ÁàÜ')) && last.damage === 0) {
                        const updated = [...prev]; updated[updated.length-1] = { ...last, damage: amount }; return updated;
                    }
                    return prev;
                });
            };

            const handleTimeout = () => {
                if (processingTimeout.current) return;
                processingTimeout.current = true;
                const s = stateRef.current;
                const victim = s.turn; // 'host' or 'guest'
                
                // HOST AUTHORITY for Timeout
                let h = s.isHost ? s.myHp : s.oppHp;
                let g = s.isHost ? s.oppHp : s.myHp;
                
                if (victim === 'host') h = Math.max(0, h - 1);
                else g = Math.max(0, g - 1);
                
                const nextTurn = s.turn === 'host' ? 'guest' : 'host';
                const nextStartTime = Date.now() + 3000 + TURN_ANIM_DURATION;
                
                // Update Host state
                if(s.isHost) {
                     setMyHp(h); setOppHp(g);
                     setDamageAlert({ target: victim === 'host' ? 'me' : 'opp', amount: 1, reason: '„Çø„Ç§„É†„Ç™„Éº„Éê„Éº' });
                     AudioSys.playSE('damage'); setTimeout(() => setDamageAlert(null), 2000);
                }

                setHistory(prev => [...prev, { type: 'timeout', owner: victim }]);
                setTurn(nextTurn); setTurnStartTime(nextStartTime);
                triggerTurnAnim(nextTurn === 'host' ? 'me' : 'rival', 3000);
                
                send({ type: 'TIMEOUT_PENALTY', victim, newHostHp: h, newGuestHp: g, nextTurn, startTime: nextStartTime });
                
                // Check Game Over (Host checks both)
                if (h <= 0 || g <= 0) {
                     const winner = h <= 0 ? 'guest' : 'host'; // If host died, guest wins
                     // Note: if both die, host loses? Simple logic for now.
                     setTimeout(() => {
                         setPhase('result');
                         if ((isHost && winner === 'host') || (!isHost && winner === 'guest')) AudioSys.playSE('win');
                         send({ type: 'GAME_OVER', winnerId: winner, finalMyHp: g, finalOppHp: h }); // Swap for guest view? No, explicit IDs
                     }, 3000);
                } else {
                    setTimeout(() => { processingTimeout.current = false; }, 500);
                }
            };
            
            const changeTurnInternal = (next, hasDamage) => {
                const now = Date.now(); const delay = hasDamage ? 3000 : 0; const nextStartTime = now + delay + TURN_ANIM_DURATION;
                setTurn(next); setTurnStartTime(nextStartTime); triggerTurnAnim(next === (stateRef.current.isHost ? 'host' : 'guest') ? 'me' : 'rival', delay);
                if (stateRef.current.isHost) send({ type: 'TURN_CHANGE', nextTurn: next, startTime: nextStartTime, delay: delay });
            };

            const showError = (msg) => { setError(msg); AudioSys.playSE('error'); setTimeout(() => setError(''), 3000); };
            const handleRematch = () => { send({ type: 'REMATCH' }); resetGame(); };
            const resetGame = () => {
                setPhase('lobby'); setMyTopic(''); setOppTopic(''); setSelectedTopic(null); setNgWords({ high:'', mid:'', low:'' }); setOppNgReady(false);
                setIsMyTopicConfirmed(false); setIsOppTopicConfirmed(false); setHistory([]); setMyHp(MAX_HP); setOppHp(MAX_HP); setDamageAlert(null);
                setTurnStartTime(0); setPhaseStartTime(0); setInitialChar(''); setIsOpponentTyping(false); processingTimeout.current = false; setTurnNotify(null);
            };
            const copyId = () => { navigator.clipboard.writeText(myId); showError('„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü'); };
            const isMyTurn = turn === (isHost?'host':'guest');

            return (
                <div className="w-full h-[100dvh] bg-pattern relative flex flex-col font-sans select-none">
                    {/* AUDIO TOGGLE */}
                    <div className="fixed top-4 right-4 z-[100]">
                        <button onClick={toggleMute} className="bg-white/80 p-2 rounded-full shadow border-2 border-slate-200">
                            <i data-lucide={isMuted ? "volume-x" : "volume-2"} className={`w-6 h-6 ${isMuted ? 'text-slate-400' : 'text-blue-500'}`}></i>
                        </button>
                    </div>

                    {error && <Toast msg={error} />}

                    {turnNotify && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center pointer-events-none bg-black/30 backdrop-blur-[2px]">
                            <div className={`transform -rotate-3 px-8 py-6 border-4 border-white shadow-2xl rounded-3xl animate-pop-in ${turnNotify === 'me' ? 'bg-blue-500' : 'bg-pink-500'}`}>
                                <h1 className="text-4xl md:text-6xl font-black text-white italic font-pop drop-shadow-md tracking-wider">
                                    {turnNotify === 'me' ? 'YOUR TURN' : 'RIVAL TURN'}
                                </h1>
                            </div>
                        </div>
                    )}

                    {damageAlert && (
                        <div className="fixed inset-0 z-[60] flex items-center justify-center pointer-events-none animate-shake">
                            <div className="relative">
                                <div className="text-[120px] font-black text-white drop-shadow-xl font-pop stroke-2 leading-none" style={{textShadow: '0 4px 0 rgba(0,0,0,0.2)'}}>-{damageAlert.amount}</div>
                                <div className="absolute top-full left-1/2 -translate-x-1/2 bg-red-500 text-white font-bold px-6 py-2 rounded-full border-4 border-white shadow-lg mt-2 whitespace-nowrap">{damageAlert.reason}</div>
                            </div>
                        </div>
                    )}

                    {phase === 'lobby' && (
                        <div className="flex-1 flex flex-col items-center justify-center p-4 space-y-8 animate-pop-in safe-top-padding">
                            <div className="text-center space-y-4 animate-title" onClick={() => { if(!AudioSys.isPlaying && !isMuted) { AudioSys.init(); AudioSys.startBGM(); }}}>
                                <div className="bg-yellow-400 text-slate-900 inline-block px-6 py-1 rounded-full font-black text-xs tracking-widest border-2 border-yellow-600 shadow-sm transform -rotate-2">NEW EXPERIENCE</div>
                                <h1 className="text-5xl md:text-7xl font-black text-slate-800 font-pop tracking-tight leading-tight">
                                    Ê¨°‰∏ñ‰ª£<br/><span className="text-blue-500">„Åó„Çä</span><span className="text-pink-500">„Å®„Çä</span>
                                </h1>
                                <div className="text-xs text-slate-400 font-bold">TAP TO START MUSIC ‚ô™</div>
                            </div>
                            <div className="pop-card p-6 w-full max-w-sm space-y-6">
                                <div>
                                    <label className="block text-xs font-bold text-slate-400 mb-2 pl-1">PLAYER NAME</label>
                                    <input value={userName} onChange={e => setUserName(e.target.value)} className="pop-input w-full px-4 py-3 text-center text-lg" placeholder="ÂêçÂâç„ÇíÂÖ•Âäõ" maxLength={8} />
                                </div>
                                <div className="space-y-4 pt-4 border-t-2 border-slate-100">
                                    <div className="flex gap-2">
                                        <input value={targetId} onChange={e => setTargetId(e.target.value.toUpperCase())} className="pop-input flex-1 px-4 py-3 text-center font-mono uppercase text-lg" placeholder="ID„ÇíÂÖ•Âäõ" />
                                        <Button onClick={connect} variant="danger" icon="swords">BATTLE</Button>
                                    </div>
                                    <div className="text-center text-xs font-bold text-slate-300">OR</div>
                                    <button className="w-full bg-blue-50 p-4 rounded-xl border-2 border-blue-100 hover:bg-blue-100 transition-colors active:scale-95" onClick={copyId}>
                                        <div className="flex justify-between items-center mb-1"><span className="text-xs font-bold text-blue-500">YOUR ID</span><i data-lucide="copy" className="w-4 h-4 text-blue-400"></i></div>
                                        <div className="text-3xl font-mono font-black text-blue-600 text-center tracking-widest">{myId || '...'}</div>
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* VS, TOPIC, ROULETTE, NG, COIN phases (Similar structure, updated styles) */}
                    {phase === 'vs' && (
                        <div className="fixed inset-0 z-50 bg-slate-900 flex flex-col md:flex-row">
                            <div className="flex-1 bg-blue-500 flex items-center justify-center relative"><div className="text-center animate-pop-in"><div className="text-blue-200 text-sm font-bold tracking-widest mb-2">CHALLENGER</div><div className="text-4xl md:text-6xl font-black text-white font-pop">{userName || 'YOU'}</div></div></div>
                            <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-20"><div className="text-7xl font-black text-yellow-400 font-pop italic drop-shadow-lg animate-pop-in">VS</div></div>
                            <div className="flex-1 bg-pink-500 flex items-center justify-center relative"><div className="text-center animate-pop-in"><div className="text-pink-200 text-sm font-bold tracking-widest mb-2">RIVAL</div><div className="text-4xl md:text-6xl font-black text-white font-pop">{oppName}</div></div></div>
                        </div>
                    )}
                    
                    {(phase === 'topic_input' || phase === 'topic_wait') && (
                         <div className="flex-1 flex flex-col items-center justify-center p-6 slide-up-enter bg-slate-50">
                            <div className="pop-card w-full max-w-md overflow-hidden">
                                <div className="bg-slate-100 p-4 border-b-2 border-slate-200 flex justify-between items-center"><h2 className="font-black text-slate-700 flex items-center gap-2"><i data-lucide="message-square" className="w-5 h-5"></i> „ÅäÈ°åÊ±∫ÂÆö</h2><div className="bg-slate-800 text-white px-3 py-1 rounded-lg font-mono font-bold">{displayTimer}</div></div>
                                {((isMyTopicConfirmed && !isHost) || (isHost && isMyTopicConfirmed && !isOppTopicConfirmed)) ? (
                                    <div className="p-12 text-center space-y-4"><div className="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto"></div><div className="font-bold text-slate-400 animate-pulse">Áõ∏Êâã„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...</div></div>
                                ) : (
                                    <div className="p-6 space-y-6"><div><input value={myTopic} onChange={e => setMyTopic(e.target.value)} className="pop-input w-full px-4 py-4 text-xl text-center" placeholder="‰æãÔºöËµ§„ÅÑ„ÇÇ„ÅÆ" /></div><div className="grid grid-cols-2 gap-4"><Button onClick={() => setMyTopic(SAMPLE_TOPICS[Math.floor(Math.random()*SAMPLE_TOPICS.length)])} variant="ghost" size="sm">„Åä„Åæ„Åã„Åõ</Button><Button onClick={submitTopic} variant="primary">Ê±∫ÂÆö</Button></div></div>
                                )}
                            </div>
                        </div>
                    )}
                    
                    {phase === 'roulette' && (
                        <div className="fixed inset-0 z-50 bg-slate-900/95 flex flex-col items-center justify-center">
                            <div className="bg-white px-10 py-8 rounded-[2rem] border-8 border-yellow-400 shadow-2xl transform scale-110"><div className="text-4xl md:text-6xl font-black text-slate-800 font-pop text-center min-w-[280px]">{rouletteDisplay}</div></div>
                        </div>
                    )}

                    {(phase === 'ng_input' || phase === 'ng_wait') && (
                        <div className="flex-1 flex flex-col h-full bg-slate-50 safe-top-padding">
                            <div className="bg-slate-800 text-white p-4 text-center shadow-lg z-10 shrink-0"><div className="text-xs font-bold text-slate-400 mb-1">CURRENT TOPIC</div><div className="text-2xl font-black font-pop">{selectedTopic?.text}</div></div>
                            <div className="flex-1 flex flex-col items-center justify-center p-4">
                                {phase === 'ng_wait' ? (
                                    <div className="text-center animate-bounce-title"><div className="text-6xl mb-4">ü§´</div><div className="font-bold text-slate-500">NG„ÉØ„Éº„Éâ„Çí„Çª„ÉÉ„Éà‰∏≠...</div></div>
                                ) : (
                                    <div className="pop-card w-full max-w-md p-6 space-y-6 animate-pop-in">
                                        <div className="flex justify-between items-center"><h2 className="font-black text-pink-500 text-lg">NG„ÉØ„Éº„ÉâË®≠ÂÆö</h2><div className="bg-pink-100 text-pink-600 px-3 py-1 rounded-lg font-mono font-bold">{displayTimer}</div></div>
                                        <div className="space-y-4">
                                            <div className="relative"><span className="absolute -left-2 top-1/2 -translate-y-1/2 -rotate-12 bg-red-600 text-white text-xs font-black px-2 py-1 rounded shadow z-10">3pt</span><input value={ngWords.high} onChange={e => setNgWords({...ngWords, high: toHiragana(e.target.value)})} className="pop-input w-full pl-12 pr-4 py-3 border-pink-200 focus:border-pink-500" placeholder="Â§ß„ÉÄ„É°„Éº„Ç∏" /></div>
                                            <div className="relative"><span className="absolute -left-2 top-1/2 -translate-y-1/2 -rotate-12 bg-orange-500 text-white text-xs font-black px-2 py-1 rounded shadow z-10">2pt</span><input value={ngWords.mid} onChange={e => setNgWords({...ngWords, mid: toHiragana(e.target.value)})} className="pop-input w-full pl-12 pr-4 py-3 border-orange-200 focus:border-orange-500" placeholder="‰∏≠„ÉÄ„É°„Éº„Ç∏" /></div>
                                            <div className="relative"><span className="absolute -left-2 top-1/2 -translate-y-1/2 -rotate-12 bg-yellow-500 text-white text-xs font-black px-2 py-1 rounded shadow z-10">1pt</span><input value={ngWords.low} onChange={e => setNgWords({...ngWords, low: toHiragana(e.target.value)})} className="pop-input w-full pl-12 pr-4 py-3 border-yellow-200 focus:border-yellow-500" placeholder="Â∞è„ÉÄ„É°„Éº„Ç∏" /></div>
                                        </div>
                                        <Button onClick={submitNg} variant="danger" fullWidth>Ê∫ñÂÇôÂÆå‰∫Ü</Button>
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {phase === 'coin' && (
                        <div className="fixed inset-0 z-50 bg-slate-900 flex items-center justify-center coin-scene">
                             <div className="relative w-48 h-48 coin-3d" style={coinStyle}>
                                <div className="coin-face bg-blue-500 text-white font-black text-3xl">YOU</div>
                                <div className="coin-face bg-pink-500 text-white font-black text-3xl" style={{ transform: 'rotateY(180deg)' }}>RIVAL</div>
                             </div>
                        </div>
                    )}

                    {(phase === 'playing' || phase === 'result') && (
                        <div className="flex flex-col h-[100dvh] bg-slate-50 safe-bottom-padding">
                            <div className="bg-white shadow-sm z-20 flex justify-between items-center h-20 border-b border-slate-200 shrink-0 px-4 pt-[var(--safe-top)]">
                                <div className="flex-1">
                                    <div className="text-xs font-bold text-pink-500 mb-1">{oppName}</div>
                                    <div className="flex gap-1">{[...Array(MAX_HP)].map((_, i) => (<div key={i} className={`w-5 h-2 rounded-full transition-all duration-300 ${i < oppHp ? 'bg-pink-500' : 'bg-slate-200'}`}></div>))}</div>
                                </div>
                                <div className="flex flex-col items-center justify-center w-24">
                                    <div className="bg-slate-800 text-white text-[10px] px-2 py-1 rounded font-bold shadow-sm max-w-[100px] truncate">{selectedTopic?.text}</div>
                                    <div className={`text-3xl font-black font-mono mt-1 ${displayTimer <= 10 ? 'text-red-500 animate-pulse' : 'text-slate-800'}`}>{isInputLocked ? '--' : displayTimer}</div>
                                </div>
                                <div className="flex-1 flex flex-col items-end">
                                    <div className="text-xs font-bold text-blue-500 mb-1">{userName}</div>
                                    <div className="flex gap-1">{[...Array(MAX_HP)].map((_, i) => (<div key={i} className={`w-5 h-2 rounded-full transition-all duration-300 ${i < myHp ? 'bg-blue-500' : 'bg-slate-200'}`}></div>))}</div>
                                </div>
                            </div>
                            
                            <div className="flex-1 overflow-y-auto p-4 space-y-4 bg-pattern scrollbar-hide" ref={scrollRef}>
                                <div className="flex justify-center py-4"><div className="bg-slate-200 text-slate-600 px-4 py-1 rounded-full font-bold text-xs flex items-center gap-2">START: <span className="text-lg text-slate-800 font-pop">{initialChar}</span></div></div>
                                {history.map((h, i) => {
                                    if(h.type === 'timeout') return <div key={i} className="flex justify-center opacity-70"><div className="bg-slate-800 text-white px-4 py-2 rounded-full text-xs font-bold">‚è∞ TIME OVER</div></div>;
                                    const isMine = h.owner === (isHost?'host':'guest');
                                    return (
                                        <div key={i} className={`flex ${isMine ? 'justify-end' : 'justify-start'} animate-pop-in`}>
                                            <div className={`relative max-w-[80%] px-5 py-3 rounded-2xl font-bold text-lg shadow-sm border-b-4 ${isMine ? 'bg-blue-500 border-blue-600 text-white rounded-tr-none' : 'bg-white border-slate-200 text-slate-800 rounded-tl-none'} ${h.damage > 0 ? 'animate-shake !bg-pink-500 !border-pink-600 !text-white' : ''}`}>
                                                {h.word}
                                            </div>
                                        </div>
                                    )
                                })}
                                {isOpponentTyping && <div className="flex justify-start"><div className="bg-slate-200 px-4 py-3 rounded-2xl rounded-tl-none flex gap-1"><div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce"></div><div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{animationDelay:'0.1s'}}></div><div className="w-2 h-2 bg-slate-400 rounded-full animate-bounce" style={{animationDelay:'0.2s'}}></div></div></div>}
                                <div className="h-4"></div>
                            </div>

                            <div className="bg-white p-3 md:p-4 border-t border-slate-200 shadow-lg z-30 shrink-0 safe-bottom-padding">
                                <div className="flex justify-between items-center mb-2 px-1">
                                    <div className="text-xs font-bold text-slate-400">NEXT: <span className="text-slate-900 font-pop text-lg">{lastChar || initialChar}</span></div>
                                    <div className={`text-xs font-black tracking-wider ${isMyTurn && !isInputLocked ? 'text-blue-500 animate-pulse' : 'text-slate-300'}`}>{isMyTurn && !isInputLocked ? '„ÅÇ„Å™„Åü„ÅÆÁï™' : 'Áõ∏Êâã„ÅÆÁï™'}</div>
                                </div>
                                <div className="flex gap-2">
                                    <input value={input} onChange={e => { setInput(e.target.value); send({ type: 'TYPING', isTyping: true }); }} onBlur={() => send({ type: 'TYPING', isTyping: false })} onKeyDown={e => e.key==='Enter' && !isInputLocked && submitWord()} disabled={!isMyTurn || isInputLocked} className="pop-input flex-1 px-4 py-3" placeholder={isMyTurn ? `${lastChar || initialChar} „Åã„Çâ„ÅØ„Åò„Åæ„ÇãË®ÄËëâ` : "ÂæÖÊ©ü‰∏≠..."} />
                                    <Button onClick={submitWord} disabled={!isMyTurn || !input || isInputLocked} icon="send" className="rounded-xl px-6" />
                                </div>
                            </div>
                            
                            {phase === 'result' && (
                                <div className="fixed inset-0 z-[100] bg-slate-900/95 flex flex-col items-center justify-center animate-pop-in p-6">
                                    <h1 className={`text-6xl md:text-8xl font-black font-pop italic transform -rotate-6 drop-shadow-lg mb-8 ${myHp > 0 ? 'text-yellow-400' : 'text-slate-500'}`}>{myHp > 0 ? 'WIN!' : 'LOSE'}</h1>
                                    <div className="bg-white p-8 rounded-[2rem] text-center w-full max-w-sm shadow-2xl">
                                        <div className="flex justify-center gap-12 mb-8">
                                            <div><div className="text-xs font-bold text-slate-400 mb-1">YOU</div><div className="text-4xl font-black text-blue-500">{myHp}</div></div>
                                            <div><div className="text-xs font-bold text-slate-400 mb-1">RIVAL</div><div className="text-4xl font-black text-pink-500">{oppHp}</div></div>
                                        </div>
                                        <Button onClick={handleRematch} variant="primary" fullWidth icon="rotate-cw">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</Button>
                                    </div>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
