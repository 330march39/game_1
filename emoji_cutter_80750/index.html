<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Emoji Cutter - Infinite Cut</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Noto+Sans+JP:wght@400;700;900&display=swap');
        
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            touch-action: none;
            overflow: hidden;
            background-color: #0f172a;
            color: white;
        }

        canvas {
            touch-action: none;
            cursor: crosshair;
        }

        .glitch-text {
            text-shadow: 2px 2px 0px #ec4899, -2px -2px 0px #6366f1;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .shake { animation: shake 0.2s ease-in-out; }

        /* UI Transitions */
        .fade-enter { opacity: 0; transform: scale(0.9); }
        .fade-enter-active { opacity: 1; transform: scale(1); transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
    </style>
</head>
<body class="h-screen w-screen relative overflow-hidden bg-slate-900">

    <!-- Background Effects -->
    <div class="absolute inset-0 z-0 opacity-20 pointer-events-none">
        <div class="absolute top-[-10%] left-[-10%] w-[60%] h-[60%] bg-purple-600 rounded-full blur-[120px] animate-pulse"></div>
        <div class="absolute bottom-[-10%] right-[-10%] w-[60%] h-[60%] bg-blue-600 rounded-full blur-[120px] animate-pulse" style="animation-delay: 1s;"></div>
    </div>

    <!-- Game Container -->
    <div class="relative z-10 w-full h-full flex flex-col">
        
        <!-- HUD -->
        <div class="flex justify-between items-start p-4 sm:p-6 select-none z-20">
            <div>
                <div class="text-xs text-slate-400 font-bold tracking-widest uppercase mb-1">SCORE</div>
                <div class="text-4xl font-black font-mono tracking-tighter drop-shadow-lg" id="scoreDisplay">0</div>
                <div id="comboDisplay" class="text-lg font-bold text-yellow-400 italic opacity-0 transition-all duration-300 transform translate-y-2">COMBO x2</div>
            </div>
            <div class="flex flex-col items-end w-1/3">
                <div class="text-xs text-slate-400 font-bold tracking-widest uppercase mb-1">TIME</div>
                <div class="w-full h-4 bg-slate-800/50 rounded-full overflow-hidden border border-slate-600/50 backdrop-blur-sm">
                    <div id="timerBar" class="h-full bg-gradient-to-r from-green-400 to-emerald-500 w-full transition-all duration-100 ease-linear shadow-[0_0_10px_rgba(16,185,129,0.5)]"></div>
                </div>
            </div>
        </div>

        <!-- Main Canvas Area -->
        <div class="flex-1 relative flex items-center justify-center overflow-hidden">
            <canvas id="gameCanvas" class="absolute inset-0 w-full h-full block"></canvas>
            
            <!-- Feedback Overlay -->
            <div id="feedbackContainer" class="absolute inset-0 pointer-events-none flex items-center justify-center overflow-hidden"></div>
        </div>

        <!-- Start Screen -->
        <div id="startScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-900/80 z-50 backdrop-blur-lg transition-all duration-500">
            <div class="mb-8 relative">
                <h1 class="text-6xl md:text-8xl font-black text-white glitch-text tracking-tighter text-center relative z-10">EMOJI<br>CUTTER</h1>
                <div class="absolute -inset-4 bg-indigo-500/20 blur-xl rounded-full -z-10"></div>
            </div>
            <p class="text-slate-300 mb-10 text-center max-w-xs font-bold leading-relaxed">
                無限のアイコンを<br>
                <span class="text-pink-400">50:50</span> に切り裂け
            </p>
            <button id="startBtn" class="group relative px-10 py-4 bg-white text-slate-900 font-black text-xl rounded-full hover:scale-105 transition-all active:scale-95 shadow-[0_0_30px_rgba(255,255,255,0.3)] overflow-hidden">
                <span class="relative z-10">GAME START</span>
                <div class="absolute inset-0 bg-gradient-to-r from-indigo-300 to-purple-300 opacity-0 group-hover:opacity-100 transition-opacity duration-300"></div>
            </button>
        </div>

        <!-- Result Screen -->
        <div id="resultScreen" class="absolute inset-0 flex flex-col items-center justify-center bg-slate-900/95 z-50 backdrop-blur-xl opacity-0 pointer-events-none transition-all duration-500 transform scale-95">
            <h2 class="text-5xl font-black text-white mb-2 tracking-widest">TIME UP</h2>
            <div class="text-7xl font-black text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-pink-400 mb-8 drop-shadow-lg" id="finalScore">0</div>
            
            <div class="grid grid-cols-2 gap-8 mb-10 w-full max-w-xs">
                <div class="bg-slate-800/50 p-4 rounded-2xl border border-slate-700 text-center backdrop-blur-md">
                    <p class="text-xs text-slate-400 uppercase font-bold mb-1">Perfect Cuts</p>
                    <p class="text-3xl font-black text-pink-400" id="finalPerfects">0</p>
                </div>
                <div class="bg-slate-800/50 p-4 rounded-2xl border border-slate-700 text-center backdrop-blur-md">
                    <p class="text-xs text-slate-400 uppercase font-bold mb-1">Max Combo</p>
                    <p class="text-3xl font-black text-yellow-400" id="finalCombo">0</p>
                </div>
            </div>
            
            <button id="restartBtn" class="px-10 py-4 bg-indigo-600 text-white font-bold rounded-full hover:bg-indigo-500 hover:shadow-[0_0_20px_rgba(99,102,241,0.6)] transition-all transform hover:-translate-y-1">
                TRY AGAIN
            </button>
        </div>
    </div>

<script>
/**
 * Emoji Cutter - Infinite Cut
 * v3.0: True Infinite Emoji Engine (Dynamic Unicode Generation)
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });
const shapeCanvas = document.createElement('canvas');
const shapeCtx = shapeCanvas.getContext('2d', { willReadFrequently: true });

const CFG = {
    initialTime: 60,
    sliceWidth: 6,
    perfectThreshold: 2.0,
    greatThreshold: 5.0,
    goodThreshold: 10.0,
    // Unicode Ranges for Emojis (Start, End)
    emojiRanges: [
        [0x1F300, 0x1F5FF], // Misc Symbols and Pictographs (Weather, Food, Music, etc)
        [0x1F600, 0x1F64F], // Emoticons (Faces)
        [0x1F680, 0x1F6FF], // Transport and Map
        [0x1F900, 0x1F9FF], // Supplemental Symbols (Food, Animals, Objects)
        [0x1FA70, 0x1FAFF], // Symbols and Pictographs Extended-A
        [0x2600, 0x27BF]    // Misc Symbols (Sun, Snowman, Soccer ball, etc)
    ]
};

let state = {
    phase: 'menu',
    score: 0,
    timeLeft: CFG.initialTime,
    combo: 0,
    maxCombo: 0,
    perfectCount: 0,
    currentPath: [],
    isDrawing: false,
    parts: [], 
    lastTime: 0,
    currentEmoji: '',
    usedEmojis: new Set() // Use Set for faster lookup
};

// --- 1. Robust Shape Generation (Emoji Engine) ---

function init() {
    resize();
    window.addEventListener('resize', resize);
    requestAnimationFrame(loop);
}

function resize() {
    const rect = canvas.parentElement.getBoundingClientRect();
    const w = Math.max(rect.width, 300);
    const h = Math.max(rect.height, 300);
    
    canvas.width = w;
    canvas.height = h;
    shapeCanvas.width = w;
    shapeCanvas.height = h;
    
    if (state.phase === 'menu') {
        spawnNewShape(true);
    } else if (state.phase === 'playing' && state.parts.length === 0) {
        spawnNewShape();
    }
}

function generateRandomEmoji() {
    const range = CFG.emojiRanges[Math.floor(Math.random() * CFG.emojiRanges.length)];
    const codePoint = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
    return String.fromCodePoint(codePoint);
}

function drawCenteredEmoji(context, emoji, width, height) {
    context.globalCompositeOperation = 'source-over';
    const size = Math.min(width, height) * 0.55;
    context.textAlign = 'center';
    context.textBaseline = 'middle';
    context.font = `${size}px "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", sans-serif`;
    context.shadowColor = 'rgba(255, 255, 255, 0.3)';
    context.shadowBlur = 20;
    context.fillText(emoji, width / 2, height / 2);
    context.shadowBlur = 0;
}

// Verify if the emoji was actually drawn (not a tofu/blank)
function checkEmojiValidity(context, width, height) {
    const sampleStep = 20;
    const imgData = context.getImageData(0, 0, width, height).data;
    let pixelCount = 0;
    
    for (let i = 3; i < imgData.length; i += 4 * sampleStep) {
        if (imgData[i] > 50) {
            pixelCount++;
        }
    }
    // If extremely few pixels are drawn, it's likely unsupported or blank
    return pixelCount > 20;
}

function spawnNewShape(isBg = false) {
    state.parts = [];
    state.currentPath = [];
    state.isDrawing = false;
    
    shapeCtx.globalCompositeOperation = 'source-over';
    shapeCtx.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
    
    if (isBg) {
        drawCenteredEmoji(ctx, '⚔️', canvas.width, canvas.height);
        return;
    }

    let emoji = '';
    let isValid = false;
    let attempts = 0;
    const maxAttempts = 20; // Prevent infinite loop

    while (!isValid && attempts < maxAttempts) {
        attempts++;
        emoji = generateRandomEmoji();

        // 1. Deduplication Check
        if (state.usedEmojis.has(emoji)) {
            continue;
        }

        // 2. Render Check
        shapeCtx.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
        drawCenteredEmoji(shapeCtx, emoji, shapeCanvas.width, shapeCanvas.height);
        
        // 3. Visibility Check (Prevent tofu/blank)
        if (checkEmojiValidity(shapeCtx, shapeCanvas.width, shapeCanvas.height)) {
            isValid = true;
            state.usedEmojis.add(emoji);
            state.currentEmoji = emoji;
        }
    }

    // If we failed to find a valid emoji after many tries (rare), fallback to safe one
    if (!isValid) {
        emoji = '⭐';
        drawCenteredEmoji(shapeCtx, emoji, shapeCanvas.width, shapeCanvas.height);
    }

    // Initial draw to main canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(shapeCanvas, 0, 0);
}

// --- 2. Input Handling ---

function getPos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return { x: clientX - rect.left, y: clientY - rect.top };
}

canvas.addEventListener('mousedown', startDraw);
canvas.addEventListener('touchstart', startDraw, {passive: false});
window.addEventListener('mousemove', drawMove);
window.addEventListener('touchmove', drawMove, {passive: false});
window.addEventListener('mouseup', endDraw);
window.addEventListener('touchend', endDraw);

function startDraw(e) {
    if (state.phase !== 'playing') return;
    if (state.parts.length > 0) return;
    e.preventDefault();
    state.isDrawing = true;
    state.currentPath = [getPos(e)];
}

function drawMove(e) {
    if (!state.isDrawing) return;
    const pos = getPos(e);
    state.currentPath.push(pos);
}

function endDraw(e) {
    if (!state.isDrawing) return;
    state.isDrawing = false;
    
    if (state.currentPath.length > 5) {
        performCut();
    } else {
        state.currentPath = [];
    }
}

// --- 3. Physics & Cutting Logic ---

function performCut() {
    shapeCtx.globalCompositeOperation = 'destination-out';
    shapeCtx.beginPath();
    shapeCtx.moveTo(state.currentPath[0].x, state.currentPath[0].y);
    
    for (let i = 1; i < state.currentPath.length; i++) {
        const p0 = state.currentPath[i-1];
        const p1 = state.currentPath[i];
        const midX = (p0.x + p1.x) / 2;
        const midY = (p0.y + p1.y) / 2;
        shapeCtx.quadraticCurveTo(p0.x, p0.y, midX, midY);
    }
    const last = state.currentPath[state.currentPath.length-1];
    shapeCtx.lineTo(last.x, last.y);
    
    shapeCtx.lineWidth = CFG.sliceWidth;
    shapeCtx.lineCap = 'round';
    shapeCtx.lineJoin = 'round';
    shapeCtx.stroke();
    shapeCtx.globalCompositeOperation = 'source-over';

    analyzeAndSeparate();
}

function analyzeAndSeparate() {
    const w = shapeCanvas.width;
    const h = shapeCanvas.height;
    const imgData = shapeCtx.getImageData(0, 0, w, h);
    const data = imgData.data;
    const visited = new Uint8Array(w * h);
    const islands = [];
    const scanStep = 8;

    for (let y = 0; y < h; y += scanStep) {
        for (let x = 0; x < w; x += scanStep) {
            const idx = y * w + x;
            if (data[idx * 4 + 3] > 50 && visited[idx] === 0) {
                const part = extractPart(x, y, w, h, data, visited);
                if (part.pixelCount > 200) { 
                    islands.push(part);
                }
            }
        }
    }

    if (islands.length >= 2) {
        handleSuccess(islands);
    } else {
        state.currentPath = [];
    }
}

function extractPart(startX, startY, w, h, sourceData, visited) {
    const stack = [startX, startY];
    let pixelCount = 0;
    let minX = w, maxX = 0, minY = h, maxY = 0;
    const pixelIndices = [];
    
    while (stack.length > 0) {
        const y = stack.pop();
        const x = stack.pop();
        const idx = y * w + x;

        if (visited[idx] === 1) continue;
        visited[idx] = 1;
        pixelCount++;
        pixelIndices.push(idx);

        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;

        if (x+1 < w && visited[idx+1]===0 && sourceData[(idx+1)*4+3]>50) stack.push(x+1, y);
        if (x-1 >=0 && visited[idx-1]===0 && sourceData[(idx-1)*4+3]>50) stack.push(x-1, y);
        if (y+1 < h && visited[idx+w]===0 && sourceData[(idx+w)*4+3]>50) stack.push(x, y+1);
        if (y-1 >=0 && visited[idx-w]===0 && sourceData[(idx-w)*4+3]>50) stack.push(x, y-1);
    }

    const partW = maxX - minX + 1;
    const partH = maxY - minY + 1;
    const pad = 2;
    const safeW = partW + pad*2;
    const safeH = partH + pad*2;
    
    const partCanvas = document.createElement('canvas');
    partCanvas.width = safeW;
    partCanvas.height = safeH;
    const partCtx = partCanvas.getContext('2d');
    const partImgData = partCtx.createImageData(safeW, safeH);
    
    for (let i = 0; i < pixelIndices.length; i++) {
        const idx = pixelIndices[i];
        const gx = idx % w;
        const gy = Math.floor(idx / w);
        
        const localX = gx - minX + pad;
        const localY = gy - minY + pad;
        const localIdx = (localY * safeW + localX) * 4;
        
        partImgData.data[localIdx] = sourceData[idx*4];
        partImgData.data[localIdx+1] = sourceData[idx*4+1];
        partImgData.data[localIdx+2] = sourceData[idx*4+2];
        partImgData.data[localIdx+3] = sourceData[idx*4+3];
    }
    
    partCtx.putImageData(partImgData, 0, 0);

    return {
        pixelCount,
        canvas: partCanvas,
        x: minX - pad,
        y: minY - pad,
        cx: minX + partW/2,
        cy: minY + partH/2,
        vx: 0, vy: 0, rot: 0, vr: 0
    };
}

function handleSuccess(islands) {
    islands.sort((a, b) => b.pixelCount - a.pixelCount);
    
    const partA = islands[0];
    const partB = islands[1];
    const totalPixels = partA.pixelCount + partB.pixelCount;
    
    const ratioA = (partA.pixelCount / totalPixels) * 100;
    const ratioB = (partB.pixelCount / totalPixels) * 100;
    const diff = Math.abs(50 - ratioA);

    const pStart = state.currentPath[0];
    const pEnd = state.currentPath[state.currentPath.length-1];
    
    const cutAngle = Math.atan2(pEnd.y - pStart.y, pEnd.x - pStart.x);
    const perpAngle = cutAngle + Math.PI/2;
    
    const cp = (pEnd.x - pStart.x)*(partA.cy - pStart.y) - (pEnd.y - pStart.y)*(partA.cx - pStart.x);
    const dir = cp > 0 ? 1 : -1;
    
    const speed = 8;
    
    partA.vx = Math.cos(perpAngle) * speed * dir;
    partA.vy = Math.sin(perpAngle) * speed * dir;
    partA.vr = (Math.random()-0.5) * 0.15;
    
    partB.vx = -partA.vx;
    partB.vy = -partA.vy;
    partB.vr = (Math.random()-0.5) * 0.15;

    state.parts = [partA, partB];
    state.currentPath = [];

    processScore(diff, ratioA, ratioB);
}

function processScore(diff, r1, r2) {
    let points = 0;
    let label = "";
    let colorClass = "";
    let timeBonus = 0;

    if (diff <= CFG.perfectThreshold) {
        label = "PERFECT";
        colorClass = "text-pink-500";
        points = 1000;
        state.combo++;
        state.perfectCount++;
        timeBonus = 2;
        spawnConfetti(canvas.width/2, canvas.height/2);
    } else if (diff <= CFG.greatThreshold) {
        label = "GREAT";
        colorClass = "text-green-400";
        points = 500;
        state.combo++;
        timeBonus = 1;
    } else if (diff <= CFG.goodThreshold) {
        label = "GOOD";
        colorClass = "text-blue-400";
        points = 100;
        state.combo = 0;
    } else {
        label = "BAD";
        colorClass = "text-slate-500";
        points = 10;
        state.combo = 0;
    }

    if (state.combo > state.maxCombo) state.maxCombo = state.combo;
    
    const multiplier = 1 + (Math.min(state.combo, 10) * 0.1);
    points = Math.floor(points * multiplier);
    
    state.score += points;
    state.timeLeft = Math.min(state.timeLeft + timeBonus, 60);

    updateUI();
    showFloatingText(label, `${r1.toFixed(1)}% / ${r2.toFixed(1)}%`, colorClass);
    
    document.body.classList.remove('shake');
    void document.body.offsetWidth;
    document.body.classList.add('shake');

    setTimeout(() => {
        if (state.phase === 'playing') {
            spawnNewShape();
        }
    }, 800);
}

// --- 4. Game Loop ---

function loop(timestamp) {
    const dt = (timestamp - state.lastTime) / 1000;
    state.lastTime = timestamp;

    if (state.phase === 'playing') {
        state.timeLeft -= dt;
        if (state.timeLeft <= 0) {
            state.timeLeft = 0;
            gameOver();
        }
        updateUIElements();
    }

    render();
    requestAnimationFrame(loop);
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (state.phase === 'playing') {
        if (state.parts.length > 0) {
            for (let part of state.parts) {
                part.x += part.vx;
                part.y += part.vy;
                part.vy += 0.5; // Gravity
                part.rot += part.vr;
                
                ctx.save();
                const cx = part.x + part.canvas.width/2;
                const cy = part.y + part.canvas.height/2;
                ctx.translate(cx, cy);
                ctx.rotate(part.rot);
                ctx.drawImage(part.canvas, -part.canvas.width/2, -part.canvas.height/2);
                ctx.restore();
            }
        } else {
            ctx.drawImage(shapeCanvas, 0, 0);
        }

        if (state.isDrawing && state.currentPath.length > 0) {
            ctx.beginPath();
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 5;
            
            ctx.moveTo(state.currentPath[0].x, state.currentPath[0].y);
            for (let i = 1; i < state.currentPath.length; i++) {
                const p0 = state.currentPath[i-1];
                const p1 = state.currentPath[i];
                const midX = (p0.x + p1.x) / 2;
                const midY = (p0.y + p1.y) / 2;
                ctx.quadraticCurveTo(p0.x, p0.y, midX, midY);
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        updateParticles();
    }
}

// --- 5. UI & Effects ---

let particles = [];
function spawnConfetti(x, y) {
    for(let i=0; i<30; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random()-0.5)*25,
            vy: (Math.random()-0.5)*25,
            life: 1.0,
            color: `hsl(${Math.random()*360}, 90%, 60%)`
        });
    }
}

function updateParticles() {
    for(let i=particles.length-1; i>=0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        p.vy += 1.0;
        
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
        
        if(p.life <= 0) particles.splice(i,1);
    }
}

function showFloatingText(text, subtext, colorClass) {
    const container = document.getElementById('feedbackContainer');
    const el = document.createElement('div');
    el.className = `absolute flex flex-col items-center animate-[pop_0.6s_cubic-bezier(0.34,1.56,0.64,1)_forwards] select-none`;
    el.innerHTML = `
        <span class="text-6xl font-black italic ${colorClass} drop-shadow-2xl stroke-black tracking-tighter" style="-webkit-text-stroke: 3px black;">${text}</span>
        <span class="text-2xl font-bold text-white drop-shadow-md bg-black/50 px-6 py-2 rounded-full mt-2 border border-white/20 backdrop-blur-md">${subtext}</span>
    `;
    container.appendChild(el);
    while(container.children.length > 3) {
        container.removeChild(container.firstChild);
    }
    setTimeout(() => { if(el.parentNode) el.parentNode.removeChild(el); }, 1000);
}

function updateUIElements() {
    const pct = Math.max(0, (state.timeLeft / 60) * 100);
    const bar = document.getElementById('timerBar');
    bar.style.width = `${pct}%`;
    
    if (pct < 20) bar.className = "h-full w-full bg-red-500 shadow-[0_0_15px_rgba(239,68,68,0.8)] animate-pulse";
    else if (pct < 50) bar.className = "h-full w-full bg-yellow-400 shadow-[0_0_10px_rgba(250,204,21,0.5)]";
    else bar.className = "h-full w-full bg-gradient-to-r from-green-400 to-emerald-500 shadow-[0_0_10px_rgba(16,185,129,0.5)]";
}

function updateUI() {
    document.getElementById('scoreDisplay').innerText = state.score;
    const comboEl = document.getElementById('comboDisplay');
    if (state.combo > 1) {
        comboEl.innerText = `COMBO x${state.combo}`;
        comboEl.style.opacity = '1';
        comboEl.style.transform = 'translateY(0)';
    } else {
        comboEl.style.opacity = '0';
        comboEl.style.transform = 'translateY(10px)';
    }
}

function startGame() {
    state = {
        phase: 'playing',
        score: 0,
        timeLeft: CFG.initialTime,
        combo: 0,
        maxCombo: 0,
        perfectCount: 0,
        currentPath: [],
        isDrawing: false,
        parts: [],
        lastTime: performance.now(),
        usedEmojis: new Set(),
        currentEmoji: ''
    };
    particles = [];

    updateUI();
    spawnNewShape();
    
    const startScreen = document.getElementById('startScreen');
    startScreen.classList.add('opacity-0', 'pointer-events-none');
    
    const resultScreen = document.getElementById('resultScreen');
    resultScreen.classList.add('opacity-0', 'pointer-events-none', 'scale-95');
    resultScreen.classList.remove('opacity-100', 'pointer-events-auto', 'scale-100');
}

function gameOver() {
    state.phase = 'result';
    document.getElementById('finalScore').innerText = state.score;
    document.getElementById('finalPerfects').innerText = state.perfectCount;
    document.getElementById('finalCombo').innerText = state.maxCombo;
    
    const resultScreen = document.getElementById('resultScreen');
    resultScreen.classList.remove('opacity-0', 'pointer-events-none', 'scale-95');
    resultScreen.classList.add('opacity-100', 'pointer-events-auto', 'scale-100');
}

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);

init();

</script>
</body>
</html>
